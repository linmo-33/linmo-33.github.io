<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ArrayList和LinkedList</title>
      <link href="/2023/10/19/ArrayList%E5%92%8CLinkedList/"/>
      <url>/2023/10/19/ArrayList%E5%92%8CLinkedList/</url>
      
        <content type="html"><![CDATA[<h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><blockquote><p><strong>时间复杂度</strong></p></blockquote><p>时间复杂度分析：评估代码的执行时耗</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求1+n的累加和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        sum = sum+i；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>假如每行代码的执行耗时一样：1ms</p></li><li><p>分析这段代码总执行多少行？ </p><p>3n+3</p></li><li><p>代码耗时总时间：T(n)&#x3D;(3n+3)*1ms</p></li></ol><ul><li><p>大O表示法：不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong> </p></li><li><p>T(n)与代码的执行次数成正比（<strong>代码行数越多，执行时间越长</strong>）</p><p>​<strong>T(n) &#x3D; O(3n + 3)      &#x3D;&gt;         T(n) &#x3D; O(n)</strong></p></li><li><p>当很大时，公式中的<strong>低阶</strong>，<strong>常量</strong>，<strong>系数</strong>三部分并不左右其增长趋势，因此可以忽略，我们只需要记录一个最大的量级就可以了</p></li></ul><p>常见复杂度表达形式</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310191543455.png" alt="image-20231019154241013"></p><p><strong>复杂度分析就是要弄清楚代码的执行次数和数据规模之间的关系</strong></p><blockquote><p><strong>空间复杂度</strong></p></blockquote><p>空间复杂度全称是渐新进空间复杂度，表示算法占用的额外存储空间与数据规模之间的增长关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        sum = sum+i；</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sum已经初始化了空间 int sum &#x3D; 0 ; 所以空间复杂度为O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> n)</span>&#123; </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n]; </span><br><span class="line">    <span class="keyword">for</span> (i;i&lt;n;++i)&#123; </span><br><span class="line">       a[i]=i*i;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">       System.out.println(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组a的空间是随着n的变化而变化，所以空间复杂度为O(n)</p><h2 id="ArrayList-数据结构-数组"><a href="#ArrayList-数据结构-数组" class="headerlink" title="ArrayList-数据结构-数组"></a>ArrayList-数据结构-数组</h2><p>数组(Array)是一种用<strong>连续的内存空间</strong>存储<strong>相同数据类型</strong>数据的线性数据结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arry = &#123;<span class="number">22</span>,<span class="number">33</span>,<span class="number">88</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310191607721.png" alt="image-20231019160716661"></p><p><strong>数组如何获取其他元素的地址值？</strong></p><p><strong>寻址公式</strong>：a[i]&#x3D;baseAddress+i*dataTypeSize</p><ul><li>baseAddress:数组的首地址 </li><li>dataTypeSize:代表数组中元素类型的大小，int型的数据，dataTypeSize&#x3D;4个字节</li></ul><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310191612697.png" alt="image-20231019161216656"></p><p>a[1] &#x3D; 10 + 1*4 &#x3D; 14</p><p><strong>为什么数组索引从0开始呢？假如从1开始不行吗？</strong></p><ul><li>在根据数组索引获取元素的时候，会用索引和寻址公式来计算内存所对应的元素数据，寻址公式是：数组的首地址+索引乘以存储数据的类型大小</li><li>如果数组的索引从1开始，寻址公式中，就需要增加一次减法操作，对于CPU来说就多了一次指令，性能不高。</li></ul><p><strong>查找的时间复杂度</strong></p><ul><li>随机（通过下标）查询的时间复杂度是O(1)</li><li>查找元素（未知下标）的时间复杂度是O(n)</li><li>查找元素(未知下标但排序)通过二分查找的时间复杂度是O(logn)</li></ul><p><strong>插入和删除时间复杂度</strong></p><p>插入和删除的时候，为了保证数组的内存连续性，需要挪动数组元素，平均时间复杂度为O(n)</p><h2 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList-源码分析"></a>ArrayList-源码分析</h2><blockquote><p><strong>成员变量</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量 capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于空实例的共享空数组实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于默认大小的空实例的共享空数组实例。</span></span><br><span class="line"><span class="comment"> * 我们将其与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时要膨胀多少</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储ArrayList元素的数组缓冲区。ArrayList的容量就是这个数组缓冲区的长度.</span></span><br><span class="line"><span class="comment"> * 当添加第一个元素时，任何具有elementData==DEFAULTCAPACITY EMPTY ELEMENTDATA的空</span></span><br><span class="line"><span class="comment"> * ArrayList都将扩展为DEFAULT CAPACITY</span></span><br><span class="line"><span class="comment"> * 当前对橡不参与序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList的大小（它包含的元素数量）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure><blockquote><p><strong>构造函数</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带初始化容量的构造函数 </span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//空参的构造函数 默认创建空集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将collection对象转换成数组，然后将数组的地址的赋给elementData</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>添加和扩容操作</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">2</span>;i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.add(<span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>第1次添加数据</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310191701013.png" alt="image-20231019170059861"></p><p>第2-10次添加数据</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310191714914.png" alt="image-20231019171417797"></p><p>第11次添加数据</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310191715329.png" alt="image-20231019171509219"></p><p><strong>ArrayList-底层实现原理</strong></p><ul><li>ArrayList底层是用动态的数组实现的 </li><li>ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10 </li><li>ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组 </li><li>ArrayList在添加数据的时候<ul><li>确保数组已使用长度(siz)加1之后足够存下下一个数据</li><li>计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用gow方法扩容（原来的1.5倍）</li><li>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。</li><li>返回添加成功布尔值。</li></ul></li></ul><p><strong>如何实现数组和List之间的转换</strong></p><ul><li>数组转List    使用JDK中java.util.Arrays工具类的asList方法 </li><li>List转数组    使用List的toArray方法。无参toArray()方法返回 Objects数组，传入初始化长度的数组对象，返回该对象数组</li></ul><p><strong>用Arrays.asList转List后，如果修改了数组内容，list受影响吗</strong> </p><p>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址 </p><p><strong>List用toArray转数组后，如果修改了List内容，数组受影响吗</strong> </p><p>list用了toArray转数组后，如果修改了Iist内容，数组不会影响，当调用了toArray以后，在底层它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</p><h2 id="LinkedList-数据结构"><a href="#LinkedList-数据结构" class="headerlink" title="LinkedList-数据结构"></a>LinkedList-数据结构</h2><blockquote><p><strong>单向链表</strong></p></blockquote><ul><li>链表中的每一个元素称之为结点</li><li>(Node)物理存储单元上，非连续、非顺序的存储结构</li><li>单向链表：每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。记录下个结点地址的指针叫作后继指针next</li></ul><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310191735108.png" alt="image-20231019173504060"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt;&#123;</span><br><span class="line">E item;</span><br><span class="line">Node&lt;E&gt;next;</span><br><span class="line">    </span><br><span class="line">Node(Node&lt;E&gt;prev,E element,Node&lt;E&gt;next)&#123;</span><br><span class="line"><span class="built_in">this</span>.item element;</span><br><span class="line"><span class="built_in">this</span>.next next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>双向链表</strong></p></blockquote><ul><li>每个结点不止有一个后继指针next指向后面的结点</li><li>有一个前驱指针prev指向前面的结点</li></ul><p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址</p><p>支持双向遍历，这样也带来了双向链表操作的灵活性</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310191743121.png" alt="image-20231019174318076"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt;&#123;</span><br><span class="line">E item;</span><br><span class="line">Node&lt;E&gt;next;</span><br><span class="line">Node&lt;E&gt;prev;</span><br><span class="line">    </span><br><span class="line">Node(Node&lt;E&gt;prev,E element,Node&lt;E&gt;next)&#123;</span><br><span class="line"><span class="built_in">this</span>.item element;</span><br><span class="line"><span class="built_in">this</span>.next next;</span><br><span class="line"><span class="built_in">this</span>.prevprev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2><blockquote><p><strong>底层数据结构</strong></p></blockquote><ul><li>ArrayList是动态数组的数据结构实现 </li><li>LinkedList是双向链表的数据结构实现</li></ul><blockquote><p><strong>操作数据效率</strong></p></blockquote><ul><li>ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】，LinkedList不支持下标查询</li><li>查找（未知索引）：ArrayList需要遍历，链表也需要遍历，时间复杂度都是O(n)</li><li>新增和删除<ul><li>ArrayList)尾部插入和删除，时间复杂度是O(1);其他部分增删需要挪动数组，时间复杂度是O(n) </li><li>LinkedList头尾节点增删时间复杂度是O(1),其他都需要遍历链表，时间复杂度是O(n)</li></ul></li></ul><blockquote><p><strong>内存空间占用</strong></p></blockquote><ul><li>ArrayList底层是数组，内存连续，节省内存 </li><li>LinkedList是双向链表需要存储数据，和两个指针，更占用内存</li></ul><blockquote><p><strong>线程安全</strong></p></blockquote><ul><li><p>ArrayList和LinkedList都不是线程安全的</p></li><li><p>如果需要保证线程安全，有两种方案：</p><ul><li><p>在方法内使用，局部变量则是线程安全的</p></li><li><p>使用线程安全的ArrayListi和LinkedList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt;syncArrayList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()); List&lt;Object&gt;syncLinkedList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList,LinkedLsit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/2023/10/19/HashMap/"/>
      <url>/2023/10/19/HashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是&#x3D;&#x3D;左子节点&#x3D;&#x3D;和&#x3D;&#x3D;右子节点&#x3D;&#x3D;。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</p><p>二叉树每个节点的&#x3D;&#x3D;左子树和右子树也分别满足二叉树的定义&#x3D;&#x3D;。</p><blockquote><p><strong>二叉搜索树</strong></p></blockquote><p>二叉搜索树(Binary Search Tree,BST)又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310191938532.png" alt="image-20231019193701088"></p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>&#x3D;&#x3D;<strong>红黑树(Red Black Tree)</strong>&#x3D;&#x3D;：也是一种自平衡的二叉搜索树(BST)，之前叫做平衡二叉B树(Symmetric Binary B- Tree)</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310191947478.png" alt="image-20231019194712412"></p><p>性质1：节点要么是<strong>红色</strong>，要么是<strong>黑色</strong></p><p>性质2：根节点是<strong>黑色</strong></p><p>性质3：叶子节点都是黑色的空节点</p><p>性质4：红黑树中红色节点的子节点都是黑色</p><p>性质5：从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</p><p><strong>在添加或删除节点的时候，如果不符合这些性质会发生旋转，以达到所有的性质</strong></p><p><strong>保证平衡</strong></p><p><strong>红黑树的复杂度</strong></p><ul><li><p>查找：</p><p>红黑树也是一棵BST(二叉搜索树)树，查找操作的时间复杂度为：&#x3D;&#x3D;O(log n)&#x3D;&#x3D;</p></li><li><p>添加：</p><p>添加先要从根节点开始找到元素添加的位置，时间复杂度O(Iog n)</p><p>添加完成后涉及到复杂度为O(1)的旋转调整操作</p><p>故整体复杂度为：&#x3D;&#x3D;O(log n)&#x3D;&#x3D;</p></li><li><p>删除：</p><p>首先从根节点开始找到被删除元素的位置，时间复杂度O(log n)</p><p>删除完成后涉及到复杂度为O(1)的旋转调整操作</p><p>故整体复杂度为：&#x3D;&#x3D;O(logn)&#x3D;&#x3D;</p></li></ul><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>在HashMap中的最重要的一个数据结构就是散列表，在散列表中又使用到了红黑树和链表</p><p>散列表(Hash Table)又名&#x3D;&#x3D;哈希表&#x2F;Hash表&#x3D;&#x3D;，是根据键(Key)直接访问在内存存储位置值(Value)的数据结构，它是由数组演化而来的，利用了数组支持按照下标进行随机访问数据的特性 </p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310192017966.png" alt="image-20231019201744902"></p><p>将键(key)映射为数组下标的函数叫做散列函数。可以表示为：hashValue&#x3D;hash(key)</p><p>散列函数的基本要求：</p><ul><li>散列函数计算得到的散列值必须是大于等于0的正整数，因为hashValue需要作为数组的下标。</li><li>如果key1 &#x3D;&#x3D; key2，那么经过hash后得到的哈希值也必相同即：hash(key1) &#x3D;&#x3D; hash(key2)</li><li><strong>如果key1 !&#x3D; key2,那么经过hash后得到的哈希值也必不相同即：hash(key1) !&#x3D; hash(key2)</strong></li></ul><blockquote><p><strong>散列冲突</strong></p></blockquote><p>实际的情况下想找一个散列函数能够做到对于不同的ky计算得到的散列值都不同几乎是不可能的，即便像著名的 MD5,SHA等哈希算法也无法避免这一情况，这就是散列冲突（或者哈希冲突，哈希碰撞，就是指多个key映射到同一个数组下标位置)</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310192020220.png" alt="image-20231019202048168"></p><blockquote><p><strong>散列冲突-链表法（拉链）</strong></p></blockquote><p>在散列表中，数组的每个下标位置我们可以称之为&#x3D;&#x3D;桶(bucket)&#x3D;&#x3D;或者&#x3D;&#x3D;槽(slot)&#x3D;&#x3D;,每个桶（槽）会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中，</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310192024699.png" alt="image-20231019202418644"></p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><blockquote><p><strong>HashMap的实现原理</strong></p></blockquote><p>HashMap的数据结构：底层使用hash表数据结构，即数组和链表或红黑树</p><ol><li>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</li><li>存储时，如果出现hash值相同的key，此时有两种情况。<ol><li>如果key相同，则覆盖原始值；</li><li>如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310192033673.png" alt="image-20231019203323626"></p><p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p> Jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时并且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。扩容resize()时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表</p><blockquote><p><strong>HashMap的put方法的具体流程</strong></p></blockquote><p>HashMap源码-常见属性</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310192040763.png" alt="image-20231019204016673"></p><p>HashMap源码-构造函数</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310192042604.png" alt="image-20231019204208562"></p><p>HashMap是懒惰加载，在创建对象时并没有初始化数组</p><p>在无参的构造函数中，设置了默认的加载因子是0.75</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310192134701.png" alt="image-20231019213446594"></p><p>put方法流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断数组是否未初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果未初始化，调用resize方法 进行初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//通过 &amp; 运算求出该数据（key）的数组下标并判断该下标位置是否有数据</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//如果没有，直接将数据放在该下标位置</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//该数组下标有数据的情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//判断该位置数据的key和新来的数据是否一样</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//如果一样，证明为修改操作，该节点的数据赋值给e,后边会用到</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//判断是不是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//如果是红黑树的话，进行红黑树的操作</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//新数据和当前数组既不相同，也不是红黑树节点，证明是链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//判断next节点，如果为空的话，证明遍历到链表尾部了</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//把新值放入链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//因为新插入了一条数据，所以判断链表长度是不是大于等于8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//如果是，进行转换红黑树操作</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断链表当中有数据相同的值，如果一样，证明为修改操作</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//把下一个节点赋值为当前节点</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断e是否为空（e值为修改操作存放原数据的变量）</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">//不为空的话证明是修改操作，取出老值</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">//一定会执行  onlyIfAbsent传进来的是false</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//将新值赋值当前节点</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//返回老值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计数器，计算当前节点的修改次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//当前数组中的数据数量如果大于扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">//进行扩容操作</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//空方法</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">//添加操作时 返回空值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>判断键值对数组table是否为空或为null,否则执行resize()进行扩容（初始化） </li><li>根据键值key计算hash值得到数组索引 </li><li>判断table[i] &#x3D;&#x3D; null,条件成立，直接新建节点添加 </li><li>如果table[i] &#x3D;&#x3D; null,不成立 <ol><li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value </li><li>判断table[i]是否为treeNode,即table[i]是否是红黑树，如果是红黑树，则直接在树中插入键值对 </li><li>遍历table[i],链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，遍历过程中若发现key已经存在直接覆盖value</li></ol></li><li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold(数组长度*0.75)，如果超过，进行扩容。</li></ol><blockquote><p><strong>HashMap的扩容机制</strong></p></blockquote><p>  <img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310201328982.png" alt="image-20231020132811488"></p><ul><li>在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度*0.75）</li><li>每次扩容的时候，都是扩容之前容量的2倍</li><li>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中<ul><li>没有hash冲突的节点，则直接使用e.hash &amp; (newCap-1)计算新数组的索引位置</li><li>如果是红黑树，走红黑树的添加</li><li>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</li></ul></li></ul><blockquote><p><strong>HashMap的寻址算法</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key,V value)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key),key,value,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扰动算法，使hash值更加均匀，减少hash冲突</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span>&#123; </span><br><span class="line">    <span class="type">int</span> h; </span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode())^(h &gt;&gt;<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(n-1)&amp;hash:得到数组中的索引，代替取模，性能更好数组长度必须是2的n次幂</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash,K key,V value,<span class="type">boolean</span> onlylfAbsent, <span class="type">boolean</span> evict)</span>&#123; </span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n-<span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>计算对象的hashCode()</li><li>再进行调用hash()方法进行二次哈希，hashcode值右移16位再异或运算，让哈希分布更为均匀</li><li>最后(capacity1)&amp;hash得到索引</li></ul><p><strong>为何HashMap的数组长度一定是2的次幂？</strong></p><ul><li>计算索引时效率更高：如果是2的次幂可以使用位与运算代替取模</li><li>扩容时重新计算索引效率更高：hash &amp; oldCap &#x3D;&#x3D; 0的元素留在原来位置，否则新位置 &#x3D; I旧位置 + oldCap</li></ul><blockquote><p><strong>HashMap在1.7情况下的多线程死循环问题</strong></p></blockquote><p>在jdk1.7的hashmapi中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环</p><p>比如说，现在有两个线程</p><p>线程一：读取到当前的nashmapi数据，数据中一个链表，在准备扩容时，线程二介入</p><p>线程二：也读取hashmap,直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB,扩容后的顺序是BA,线程二执行结束。</p><p>线程一：继续执行的时候就会出现死循环的问题。</p><p>线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的neXt指向了A,所以B-&gt;A-&gt;B,形成循环。当然，JDK8将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），&#x3D;&#x3D;<strong>尾插法</strong>&#x3D;&#x3D;，就避免了jdk7中死循环的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis篇-缓存</title>
      <link href="/2023/10/18/Redis%E7%AF%87-%E7%BC%93%E5%AD%98/"/>
      <url>/2023/10/18/Redis%E7%AF%87-%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis使用场景-缓存-缓存穿透"><a href="#Redis使用场景-缓存-缓存穿透" class="headerlink" title="Redis使用场景-缓存-缓存穿透"></a>Redis使用场景-缓存-缓存穿透</h2><p><strong>缓存穿透</strong>：查询一个不存在的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库</p><p><strong>解决方案一</strong>：缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存</p><p>优点：简单</p><p>缺点：消耗内存，可能会发生不一致的问题</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310181124681.png" alt="image-20231018112405592"></p><p><strong>解决方案二</strong>：布隆过滤器</p><p>优点：内存占用较少，没有多余key</p><p>缺点：实现复杂，存在误判</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310181358187.png" alt="image-20231018112311654"></p><h2 id="Redis使用场景-缓存-缓存击穿"><a href="#Redis使用场景-缓存-缓存击穿" class="headerlink" title="Redis使用场景-缓存-缓存击穿"></a>Redis使用场景-缓存-缓存击穿</h2><p><strong>缓存击穿</strong>：给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个key有大量的并发请求过来，这些并发的请求可能会瞬间把DB压垮</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310181125239.png" alt="image-20231018112553177"></p><p><strong>解决方案一</strong>：互斥锁</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310181128465.png" alt="image-20231018112838406"></p><p>强一致，性能差</p><p><strong>解决方案二</strong>：逻辑过期</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310181132902.png" alt="image-20231018113207779"></p><p>高可用，性能优，不能保证数据的强一致</p><h2 id="Redis使用场景-缓存-缓存雪崩"><a href="#Redis使用场景-缓存-缓存雪崩" class="headerlink" title="Redis使用场景-缓存-缓存雪崩"></a>Redis使用场景-缓存-缓存雪崩</h2><p><strong>缓存雪崩</strong>：是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p><strong>解决方案</strong>：</p><ul><li>给不同的Key的TTL(过期时间)添加随机值</li><li>利用Redis集群提高服务的可用     性哨兵模式、集群模式</li><li>给缓存业务添加降级限流策略       ngxin或spring cloud gateway</li><li>给业务添加多级缓存       Guava或Caffeine</li></ul><h2 id="Redis使用场景-缓存-双写一致性"><a href="#Redis使用场景-缓存-双写一致性" class="headerlink" title="Redis使用场景-缓存-双写一致性"></a>Redis使用场景-缓存-双写一致性</h2><p><strong>双写一致性</strong>：当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p><p><strong>允许延时一致的业务，采用异步通知</strong></p><p>​    ①使用MQ中间中间件，更新数据之后，通知缓存删除</p><p>​    ②利用canal中间件，不需要修改业务代码，伪装为mysql的一个从节点，canali通过读取binlog数据更新缓存</p><p><strong>强一致性的，采用Redisson提供的读写锁</strong></p><p>​    ①共享锁：读锁readLock,加锁之后，其他线程可以共享读操作</p><p>​    ②排他锁：独占锁writeLock也叫，加锁后，阻塞其他线程读写操作</p><h2 id="Redis使用场景-缓存-持久化"><a href="#Redis使用场景-缓存-持久化" class="headerlink" title="Redis使用场景-缓存-持久化"></a>Redis使用场景-缓存-持久化</h2><blockquote><p><strong>RDB</strong></p></blockquote><p><strong>RDB</strong>全称Redis Database Backup file(Redis数据备份文件)，也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Rdis实例故障重启后，从磁盘读取快照文件，恢复数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ]redis-cli </span><br><span class="line">127.0.0.1:6379&gt;save<span class="comment">#由Redis主进程来执行RDB,会阻塞所有命令 </span></span><br><span class="line">ok </span><br><span class="line">127.0.0.1:6379&gt;bgsave<span class="comment">#开启子进程执行RDB,避免主进程受到影响 </span></span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#90o秒内，如果至少有1个key被修改，则执行bgsave </span></span><br><span class="line">save 900 1 </span><br><span class="line">save 300 10 </span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p><strong>RDB</strong>执行原理：bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入RDB文件。</p><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><blockquote><p><strong>AOF</strong></p></blockquote><p><strong>AOF</strong>全称为Append Only File(追加文件)。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no </span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line"><span class="comment">#AOF文件的名称 </span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#表示每执行一次写命令，立即记录到AOF文件 </span></span><br><span class="line">appendfsync always</span><br><span class="line"><span class="comment">#写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案 </span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment">#写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘 </span></span><br><span class="line">appendfsync no</span><br></pre></td></tr></table></figure><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个ky的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#AOF文件比上次文件增长超过多少百分比则触发重写 </span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="comment">#A0F文件体积最小多大以上才触发重写 </span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用。</p><table><thead><tr><th align="center"></th><th align="center">RDB</th><th align="center">AOF</th></tr></thead><tbody><tr><td align="center">持久化方式</td><td align="center">定时对整个内存做快照</td><td align="center">记录每一次的执行命令</td></tr><tr><td align="center">数据完整性</td><td align="center">不完整，两次备份之间会丢失</td><td align="center">相对完整，却决于刷盘策略</td></tr><tr><td align="center">文件大小</td><td align="center">会有压缩，文件体积小</td><td align="center">记录命令，文件体积大</td></tr><tr><td align="center">宕机恢复速度</td><td align="center">很快</td><td align="center">慢</td></tr><tr><td align="center">数据恢复优先级</td><td align="center">低，因为数据完整性不如AOF</td><td align="center">高，因为数据完整性高</td></tr><tr><td align="center">系统资源占用</td><td align="center">高，大量CPU和内存消耗</td><td align="center">低，主要是磁盘IO资源，但AOF重写时会占用大量的CPU和内存资源</td></tr><tr><td align="center">使用场景</td><td align="center">可以容忍数分钟的数据丢失，追求更快的启动速度</td><td align="center">对数据安全性要求较高常见</td></tr></tbody></table><h2 id="Redis使用场景-缓存-数据过期策略"><a href="#Redis使用场景-缓存-数据过期策略" class="headerlink" title="Redis使用场景-缓存-数据过期策略"></a>Redis使用场景-缓存-数据过期策略</h2><blockquote><p><strong>Redisi数据删除策略-惰性删除</strong></p></blockquote><p><strong>惰性删除</strong>：设置该key过期时间后，我们不去管它，当需要该ky时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key</p><p>优点：对CPU友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查</p><p>缺点：对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存中，内存永远不会释放</p><blockquote><p><strong>Redisi数据删除策略-定期删除</strong></p></blockquote><p><strong>定期删除</strong>：每隔一段时间，我们就对一些ky进行检查，删除里面过期的key(从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key)。</p><p>定期清理有两种模式：</p><ul><li>SLOW模式是定时任务，执行频率默认为10hz,每次不超过25ms,以通过修改配置文件redis..conf的hz选项来调整这个次数</li><li>FAST模式执行频率不固定，但两次间隔不低于2ms,每次耗时不超过1ms</li></ul><p>优点：可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。另外定期删除，也能有效释放过期键占用的内存。</p><p>缺点：难以确定删除操作执行的时长和频率。</p><p><strong>Redis的过期删除策略：惰性删除+定期删除两种策略进行配合使用</strong></p><h2 id="Redis使用场景-缓存-数据淘汰策略"><a href="#Redis使用场景-缓存-数据淘汰策略" class="headerlink" title="Redis使用场景-缓存-数据淘汰策略"></a>Redis使用场景-缓存-数据淘汰策略</h2><p><strong>数据的淘汰策略</strong>：当Redis中的内存不够用时，此时在向Redis中添加新的key,那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。</p><p>1.Redis提供了8种不同的数据淘汰策略，默认是noeviction不删除任何数据，内存不足直接报错</p><p>2.LRU:最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</p><p>3.LFU:最少频率使用。会统计每个ky的访问频率，值越小淘汰优先级越高</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis,缓存 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
