<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>消息中间件面试题</title>
      <link href="/2023/10/19/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/10/19/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="消息中间件面试题-参考回答"><a href="#消息中间件面试题-参考回答" class="headerlink" title="消息中间件面试题-参考回答"></a>消息中间件面试题-参考回答</h2><blockquote><p><strong>面试官</strong>：RabbitMQ-如何保证消息不丢失</p><p><strong>候选人</strong>：</p><p>嗯！我们当时MYSQL和Redis的数据双写一致性就是采用RabbitMQ实现同步的，这里面就要求了消息的高可用性，我们要保证消息的不丢失。主要从三个层面考虑</p><p>第一个是开启生产者确认机制，确保生产者的消息能到达队列，如果报错可以先记录到日志中，再去修复数据</p><p>第二个是开启持久化功能，确保消息未消费前在队列中不会丢失，其中的交换机、队列、和消息都要做持久化</p><p>第三个是开启消费者确认机制为auto，由spring确认消息处理成功后完成ack，当然也需要设置一定的重试次数，我们当时设置了3次，如果重试3次还没有收到消息，就将失败后的消息投递到异常交换机，交由人工处理</p><p><strong>面试官</strong>：RabbitMQ消息的重复消费问题如何解决的</p><p><strong>候选人</strong>：</p><p>嗯，这个我们还真遇到过，是这样的，我们当时消费者是设置了自动确认机制，当服务还没来得及给MQ确认的时候，服务宕机了，导致服务重启之后，又消费了一次消息。这样就重复消费了</p><p>因为我们当时处理的支付（订单|业务唯一标识），它有一个业务的唯一标识，我们再处理消息时，先到数据库查询一下，这个数据是否存在，如果不存在，说明没有处理过，这个时候就可以正常处理这个消息了。如果已经存在这个数据了，就说明消息重复消费了，我们就不需要再消费了</p><p><strong>面试官</strong>：那你还知道其他的解决方案吗？</p><p><strong>候选人</strong>：</p><p>嗯，我想想~</p><p>其实这个就是典型的幂等的问题，比如，redis分布式锁、数据库的锁都是可以的</p><p><strong>面试官</strong>：RabbitMQ中死信交换机 ? （RabbitMQ延迟队列有了解过嘛）</p><p><strong>候选人</strong>：</p><p>嗯！了解过！</p><p>我们当时的xx项目有一个xx业务，需要用到延迟队列，其中就是使用RabbitMQ来实现的。</p><p>延迟队列就是用到了死信交换机和TTL（消息存活时间）实现的。</p><p>如果消息超时未消费就会变成死信，在RabbitMQ中如果消息成为死信，队列可以绑定一个死信交换机，在死信交换机上可以绑定其他队列，在我们发消息的时候可以按照需求指定TTL的时间，这样就实现了延迟队列的功能了。</p><p>我记得RabbitMQ还有一种方式可以实现延迟队列，在RabbitMQ中安装一个死信插件，这样更方便一些，我们只需要在声明交互机的时候，指定这个就是死信交换机，然后在发送消息的时候直接指定超时时间就行了，相对于死信交换机+TTL要省略了一些步骤</p><p><strong>面试官</strong>：如果有100万消息堆积在MQ , 如何解决 ?</p><p><strong>候选人</strong>：</p><p>我在实际的开发中，没遇到过这种情况，不过，如果发生了堆积的问题，解决方案也所有很多的</p><p>第一:提高消费者的消费能力 ,可以使用多线程消费任务</p><p>第二：增加更多消费者，提高消费速度 </p><p>​ 使用工作队列模式, 设置多个消费者消费消费同一个队列中的消息</p><p>第三：扩大队列容积，提高堆积上限 </p><p>可以使用RabbitMQ惰性队列，惰性队列的好处主要是</p><p>①接收到消息后直接存入磁盘而非内存</p><p>②消费者要消费消息时才会从磁盘中读取并加载到内存</p><p>③支持数百万条的消息存储</p><p><strong>面试官</strong>：RabbitMQ的高可用机制有了解过嘛</p><p><strong>候选人</strong>：</p><p>嗯，熟悉的~</p><p>我们当时项目在生产环境下，使用的集群，当时搭建是镜像模式集群，使用了3台机器。</p><p>镜像队列结构是一主多从，所有操作都是主节点完成，然后同步给镜像节点，如果主节点宕机后，镜像节点会替代成新的主节点，不过在主从同步完成前，主节点就已经宕机，可能出现数据丢失</p><p><strong>面试官</strong>：那出现丢数据怎么解决呢？</p><p><strong>候选人</strong>：</p><p>我们可以采用仲裁队列，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于Raft协议，强一致。</p><p>并且使用起来也非常简单，不需要额外的配置，在声明队列的时候只要指定这个是仲裁队列即可</p><p><strong>面试官</strong>：Kafka是如何保证消息不丢失</p><p><strong>候选人</strong>：</p><p>嗯，这个保证机制很多，在发送消息到消费者接收消息，在每个阶段都有可能会丢失消息，所以我们解决的话也是从多个方面考虑</p><p>第一个是生产者发送消息的时候，可以使用异步回调发送，如果消息发送失败，我们可以通过回调获取失败后的消息信息，可以考虑重试或记录日志，后边再做补偿都是可以的。同时在生产者这边还可以设置消息重试，有的时候是由于网络抖动的原因导致发送不成功，就可以使用重试机制来解决</p><p>第二个在broker中消息有可能会丢失，我们可以通过kafka的复制机制来确保消息不丢失，在生产者发送消息的时候，可以设置一个acks，就是确认机制。我们可以设置参数为all，这样的话，当生产者发送消息到了分区之后，不仅仅只在leader分区保存确认，在follwer分区也会保存确认，只有当所有的副本都保存确认以后才算是成功发送了消息，所以，这样设置就很大程度了保证了消息不会在broker丢失</p><p>第三个有可能是在消费者端丢失消息，kafka消费消息都是按照offset进行标记消费的，消费者默认是自动按期提交已经消费的偏移量，默认是每隔5s提交一次，如果出现重平衡的情况，可能会重复消费或丢失数据。我们一般都会禁用掉自动提价偏移量，改为手动提交，当消费成功以后再报告给broker消费的位置，这样就可以避免消息丢失和重复消费了</p><p><strong>面试官</strong>：Kafka中消息的重复消费问题如何解决的</p><p><strong>候选人</strong>：</p><p>kafka消费消息都是按照offset进行标记消费的，消费者默认是自动按期提交已经消费的偏移量，默认是每隔5s提交一次，如果出现重平衡的情况，可能会重复消费或丢失数据。我们一般都会禁用掉自动提价偏移量，改为手动提交，当消费成功以后再报告给broker消费的位置，这样就可以避免消息丢失和重复消费了</p><p>为了消息的幂等，我们也可以设置唯一主键来进行区分，或者是加锁，数据库的锁，或者是redis分布式锁，都能解决幂等的问题</p><p><strong>面试官</strong>：Kafka是如何保证消费的顺序性</p><p><strong>候选人</strong>：</p><p>kafka默认存储和消费消息，是不能保证顺序性的，因为一个topic数据可能存储在不同的分区中，每个分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性</p><p>如果有这样的需求的话，我们是可以解决的，把消息都存储同一个分区下就行了，有两种方式都可以进行设置，第一个是发送消息时指定分区号，第二个是发送消息时按照相同的业务设置相同的key，因为默认情况下分区也是通过key的hashcode值来选择分区的，hash值如果一样的话，分区肯定也是一样的</p><p><strong>面试官</strong>：Kafka的高可用机制有了解过嘛</p><p><strong>候选人</strong>：</p><p>嗯，主要是有两个层面，第一个是集群，第二个是提供了复制机制</p><p>kafka集群指的是由多个broker实例组成，即使某一台宕机，也不耽误其他broker继续对外提供服务</p><p>复制机制是可以保证kafka的高可用的，一个topic有多个分区，每个分区有多个副本，有一个leader，其余的是follower，副本存储在不同的broker中；所有的分区副本的内容是都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader，保证了系统的容错性、高可用性</p><p><strong>面试官</strong>：解释一下复制机制中的ISR</p><p><strong>候选人</strong>：</p><p>ISR的意思是in-sync replica，就是需要同步复制保存的follower</p><p>其中分区副本有很多的follower，分为了两类，一个是ISR，与leader副本同步保存数据，另外一个普通的副本，是异步同步数据，当leader挂掉之后，会优先从ISR副本列表中选取一个作为leader，因为ISR是同步保存数据，数据更加的完整一些，所以优先选择ISR副本列表</p><p><strong>面试官</strong>：Kafka数据清理机制了解过嘛</p><p><strong>候选人</strong>：</p><p>嗯，了解过~~</p><p>Kafka中topic的数据存储在分区上，分区如果文件过大会分段存储segment</p><p>每个分段都在磁盘上以索引(xxxx.index)和日志文件(xxxx.log)的形式存储，这样分段的好处是，第一能够减少单个文件内容的大小，查找数据方便，第二方便kafka进行日志清理。</p><p>在kafka中提供了两个日志的清理策略：</p><p>第一，根据消息的保留时间，当消息保存的时间超过了指定的时间，就会触发清理，默认是168小时（ 7天）</p><p>第二是根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。这个默认是关闭的</p><p>这两个策略都可以通过kafka的broker中的配置文件进行设置</p><p><strong>面试官</strong>：Kafka中实现高性能的设计有了解过嘛</p><p><strong>候选人</strong>：</p><p>Kafka 高性能，是多方面协同的结果，包括宏观架构、分布式存储、ISR 数据同步、以及高效的利用磁盘、操作系统特性等。主要体现有这么几点：</p><p>消息分区：不受单台服务器的限制，可以不受限的处理更多的数据</p><p>顺序读写：磁盘顺序读写，提升读写效率</p><p>页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问</p><p>零拷贝：减少上下文切换及数据拷贝</p><p>消息压缩：减少磁盘IO和网络IO</p><p>分批发送：将消息打包批量发送，减少网络开销</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ.Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis篇-缓存</title>
      <link href="/2023/10/18/Redis%E7%AF%87-%E7%BC%93%E5%AD%98/"/>
      <url>/2023/10/18/Redis%E7%AF%87-%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis使用场景-缓存-缓存穿透"><a href="#Redis使用场景-缓存-缓存穿透" class="headerlink" title="Redis使用场景-缓存-缓存穿透"></a>Redis使用场景-缓存-缓存穿透</h2><p><strong>缓存穿透</strong>：查询一个不存在的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库</p><p><strong>解决方案一</strong>：缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存</p><p>优点：简单</p><p>缺点：消耗内存，可能会发生不一致的问题</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310181124681.png" alt="image-20231018112405592"></p><p><strong>解决方案二</strong>：布隆过滤器</p><p>优点：内存占用较少，没有多余key</p><p>缺点：实现复杂，存在误判</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310181358187.png" alt="image-20231018112311654"></p><h2 id="Redis使用场景-缓存-缓存击穿"><a href="#Redis使用场景-缓存-缓存击穿" class="headerlink" title="Redis使用场景-缓存-缓存击穿"></a>Redis使用场景-缓存-缓存击穿</h2><p><strong>缓存击穿</strong>：给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个key有大量的并发请求过来，这些并发的请求可能会瞬间把DB压垮</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310181125239.png" alt="image-20231018112553177"></p><p><strong>解决方案一</strong>：互斥锁</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310181128465.png" alt="image-20231018112838406"></p><p>强一致，性能差</p><p><strong>解决方案二</strong>：逻辑过期</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310181132902.png" alt="image-20231018113207779"></p><p>高可用，性能优，不能保证数据的强一致</p><h2 id="Redis使用场景-缓存-缓存雪崩"><a href="#Redis使用场景-缓存-缓存雪崩" class="headerlink" title="Redis使用场景-缓存-缓存雪崩"></a>Redis使用场景-缓存-缓存雪崩</h2><p><strong>缓存雪崩</strong>：是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p><strong>解决方案</strong>：</p><ul><li>给不同的Key的TTL(过期时间)添加随机值</li><li>利用Redis集群提高服务的可用     性哨兵模式、集群模式</li><li>给缓存业务添加降级限流策略       ngxin或spring cloud gateway</li><li>给业务添加多级缓存       Guava或Caffeine</li></ul><h2 id="Redis使用场景-缓存-双写一致性"><a href="#Redis使用场景-缓存-双写一致性" class="headerlink" title="Redis使用场景-缓存-双写一致性"></a>Redis使用场景-缓存-双写一致性</h2><p><strong>双写一致性</strong>：当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p><p><strong>允许延时一致的业务，采用异步通知</strong></p><p>​    ①使用MQ中间中间件，更新数据之后，通知缓存删除</p><p>​    ②利用canal中间件，不需要修改业务代码，伪装为mysql的一个从节点，canali通过读取binlog数据更新缓存</p><p><strong>强一致性的，采用Redisson提供的读写锁</strong></p><p>​    ①共享锁：读锁readLock,加锁之后，其他线程可以共享读操作</p><p>​    ②排他锁：独占锁writeLock也叫，加锁后，阻塞其他线程读写操作</p><h2 id="Redis使用场景-缓存-持久化"><a href="#Redis使用场景-缓存-持久化" class="headerlink" title="Redis使用场景-缓存-持久化"></a>Redis使用场景-缓存-持久化</h2><blockquote><p><strong>RDB</strong></p></blockquote><p><strong>RDB</strong>全称Redis Database Backup file(Redis数据备份文件)，也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Rdis实例故障重启后，从磁盘读取快照文件，恢复数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ]redis-cli </span><br><span class="line">127.0.0.1:6379&gt;save<span class="comment">#由Redis主进程来执行RDB,会阻塞所有命令 </span></span><br><span class="line">ok </span><br><span class="line">127.0.0.1:6379&gt;bgsave<span class="comment">#开启子进程执行RDB,避免主进程受到影响 </span></span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#90o秒内，如果至少有1个key被修改，则执行bgsave </span></span><br><span class="line">save 900 1 </span><br><span class="line">save 300 10 </span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p><strong>RDB</strong>执行原理：bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入RDB文件。</p><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><blockquote><p><strong>AOF</strong></p></blockquote><p><strong>AOF</strong>全称为Append Only File(追加文件)。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no </span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line"><span class="comment">#AOF文件的名称 </span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#表示每执行一次写命令，立即记录到AOF文件 </span></span><br><span class="line">appendfsync always</span><br><span class="line"><span class="comment">#写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案 </span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment">#写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘 </span></span><br><span class="line">appendfsync no</span><br></pre></td></tr></table></figure><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个ky的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#AOF文件比上次文件增长超过多少百分比则触发重写 </span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="comment">#A0F文件体积最小多大以上才触发重写 </span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用。</p><table><thead><tr><th align="center"></th><th align="center">RDB</th><th align="center">AOF</th></tr></thead><tbody><tr><td align="center">持久化方式</td><td align="center">定时对整个内存做快照</td><td align="center">记录每一次的执行命令</td></tr><tr><td align="center">数据完整性</td><td align="center">不完整，两次备份之间会丢失</td><td align="center">相对完整，却决于刷盘策略</td></tr><tr><td align="center">文件大小</td><td align="center">会有压缩，文件体积小</td><td align="center">记录命令，文件体积大</td></tr><tr><td align="center">宕机恢复速度</td><td align="center">很快</td><td align="center">慢</td></tr><tr><td align="center">数据恢复优先级</td><td align="center">低，因为数据完整性不如AOF</td><td align="center">高，因为数据完整性高</td></tr><tr><td align="center">系统资源占用</td><td align="center">高，大量CPU和内存消耗</td><td align="center">低，主要是磁盘IO资源，但AOF重写时会占用大量的CPU和内存资源</td></tr><tr><td align="center">使用场景</td><td align="center">可以容忍数分钟的数据丢失，追求更快的启动速度</td><td align="center">对数据安全性要求较高常见</td></tr></tbody></table><h2 id="Redis使用场景-缓存-数据过期策略"><a href="#Redis使用场景-缓存-数据过期策略" class="headerlink" title="Redis使用场景-缓存-数据过期策略"></a>Redis使用场景-缓存-数据过期策略</h2><blockquote><p><strong>Redisi数据删除策略-惰性删除</strong></p></blockquote><p><strong>惰性删除</strong>：设置该key过期时间后，我们不去管它，当需要该ky时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key</p><p>优点：对CPU友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查</p><p>缺点：对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存中，内存永远不会释放</p><blockquote><p><strong>Redisi数据删除策略-定期删除</strong></p></blockquote><p><strong>定期删除</strong>：每隔一段时间，我们就对一些ky进行检查，删除里面过期的key(从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key)。</p><p>定期清理有两种模式：</p><ul><li>SLOW模式是定时任务，执行频率默认为10hz,每次不超过25ms,以通过修改配置文件redis..conf的hz选项来调整这个次数</li><li>FAST模式执行频率不固定，但两次间隔不低于2ms,每次耗时不超过1ms</li></ul><p>优点：可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。另外定期删除，也能有效释放过期键占用的内存。</p><p>缺点：难以确定删除操作执行的时长和频率。</p><p><strong>Redis的过期删除策略：惰性删除+定期删除两种策略进行配合使用</strong></p><h2 id="Redis使用场景-缓存-数据淘汰策略"><a href="#Redis使用场景-缓存-数据淘汰策略" class="headerlink" title="Redis使用场景-缓存-数据淘汰策略"></a>Redis使用场景-缓存-数据淘汰策略</h2><p><strong>数据的淘汰策略</strong>：当Redis中的内存不够用时，此时在向Redis中添加新的key,那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。</p><p>1.Redis提供了8种不同的数据淘汰策略，默认是noeviction不删除任何数据，内存不足直接报错</p><p>2.LRU:最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</p><p>3.LFU:最少频率使用。会统计每个ky的访问频率，值越小淘汰优先级越高</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis,缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM相关面试题</title>
      <link href="/2023/10/18/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/10/18/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM相关面试题"><a href="#JVM相关面试题" class="headerlink" title="JVM相关面试题"></a>JVM相关面试题</h1><h2 id="1-JVM组成"><a href="#1-JVM组成" class="headerlink" title="1 JVM组成"></a>1 JVM组成</h2><h3 id="1-1-JVM由那些部分组成，运行流程是什么？"><a href="#1-1-JVM由那些部分组成，运行流程是什么？" class="headerlink" title="1.1 JVM由那些部分组成，运行流程是什么？"></a>1.1 JVM由那些部分组成，运行流程是什么？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p><strong>JVM是什么</strong></p><p>Java Virtual Machine Java程序的运行环境（java二进制字节码的运行环境）</p><p>好处：</p><ul><li><p>一次编写，到处运行</p></li><li><p>自动内存管理，垃圾回收机制</p></li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218144.png" alt="image-20230506094254360"></p><p><strong>JVM由哪些部分组成，运行流程是什么？</strong></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218145.png" alt="image-20230506094411247"></p><p>从图中可以看出 JVM 的主要组成部分</p><ul><li>ClassLoader（类加载器）</li><li>Runtime Data Area（运行时数据区，内存分区）</li><li>Execution Engine（执行引擎）</li><li>Native Method Library（本地库接口）</li></ul><p>运行流程：</p><p>（1）类加载器（ClassLoader）把Java代码转换为字节码</p><p>（2）运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行</p><p>（3）执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。</p><h3 id="1-2-什么是程序计数器？"><a href="#1-2-什么是程序计数器？" class="headerlink" title="1.2 什么是程序计数器？"></a>1.2 什么是程序计数器？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>程序计数器：线程私有的，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。</p><blockquote><p>javap -verbose  xx.class    打印堆栈大小，局部变量的数量和方法的参数。</p></blockquote><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218966.png" alt="image-20230506094602329"></p><p>​java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。</p><p>​那么现在有一个问题就是，当前处理器如何能够知道，对于这个被挂起的线程，它上一次执行到了哪里？那么这时就需要从程序计数器中来回去到当前的这个线程他上一次执行的行号，然后接着继续向下执行。</p><p>​程序计数器是JVM规范中唯一一个没有规定出现OOM的区域，所以这个空间也不会进行GC。</p><h3 id="1-3-你能给我详细的介绍Java堆吗"><a href="#1-3-你能给我详细的介绍Java堆吗" class="headerlink" title="1.3 你能给我详细的介绍Java堆吗?"></a>1.3 你能给我详细的介绍Java堆吗?</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>线程共享的区域：主要用来保存对象实例，数组等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218146.png" alt="image-20230506094803545"></p><ul><li>年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到老年代区间。</li><li>老年代主要保存生命周期长的对象，一般是一些老的对象</li><li>元空间保存的类信息、静态变量、常量、编译后的代码</li></ul><p>​</p><p>为了避免方法区出现OOM，所以在java8中将堆上的方法区【永久代】给移动到了本地内存上，重新开辟了一块空间，叫做<strong>元空间</strong>。那么现在就可以避免掉OOM的出现了。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218147.png" alt="image-20230506094938843"></p><h5 id="元空间-MetaSpace-介绍"><a href="#元空间-MetaSpace-介绍" class="headerlink" title="元空间(MetaSpace)介绍"></a>元空间(MetaSpace)介绍</h5><p>​在 HotSpot JVM 中，永久代（ ≈ 方法区）中用于存放类和方法的元数据以及常量池，比如Class 和 Method。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p><p>​永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即OutOfMemoryError，为此不得不对虚拟机做调优。</p><p>​那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？</p><p>官网给出了解释：<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.</span><br><span class="line"></span><br><span class="line">移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。</span><br></pre></td></tr></table></figure><p>1）由于 PermGen 内存经常会溢出，引发OutOfMemoryError，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM。</p><p>2）移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</p><p>​准确来说，Perm 区中的字符串常量池被移到了堆内存中是在 Java7 之后，Java 8 时，PermGen 被元空间代替，其他内容比如<strong>类元信息、字段、静态属性、方法、常量</strong>等都移动到元空间区。比如 java&#x2F;lang&#x2F;Object 类元信息、静态属性 System.out、整型常量等。</p><p>​元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p><h3 id="1-4-什么是虚拟机栈"><a href="#1-4-什么是虚拟机栈" class="headerlink" title="1.4 什么是虚拟机栈"></a>1.4 什么是虚拟机栈</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>Java Virtual machine Stacks (java 虚拟机栈)</p><ul><li><p>每个线程运行时所需要的内存，称为虚拟机栈，先进后出</p></li><li><p>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存</p></li><li><p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p></li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218148.png" alt="image-20230506095140595"></p><ol><li><p>垃圾回收是否涉及栈内存？</p><p>垃圾回收主要指就是堆内存，当栈帧弹栈以后，内存就会释放</p></li><li><p>栈内存分配越大越好吗？</p><p>未必，默认的栈内存通常为1024k</p><p>栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半</p></li><li><p>方法内的局部变量是否线程安全？</p><ul><li><p>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的</p></li><li><p>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</p></li><li><p>比如以下代码：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218149.png" alt="image-20230506095306061"></p></li></ul></li></ol><p><strong>栈内存溢出情况</strong></p><ul><li><p>栈帧过多导致栈内存溢出，典型问题：递归调用</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218150.png" alt="image-20230506095401637"></p></li><li><p>栈帧过大导致栈内存溢出</p></li></ul><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>组成部分：堆、方法区、栈、本地方法栈、程序计数器</p><p>1、堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。<br>2、方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。<br>3、栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。<br>4、本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。<br>5、程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</p><h3 id="1-5-能不能解释一下方法区？"><a href="#1-5-能不能解释一下方法区？" class="headerlink" title="1.5 能不能解释一下方法区？"></a>1.5 能不能解释一下方法区？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><h4 id="1-5-1-概述"><a href="#1-5-1-概述" class="headerlink" title="1.5.1 概述"></a>1.5.1 概述</h4><ul><li><p>方法区(Method Area)是各个线程共享的内存区域</p></li><li><p>主要存储类的信息、运行时常量池</p></li><li><p>虚拟机启动的时候创建，关闭虚拟机时释放</p></li><li><p>如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace</p></li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218151.png" alt="image-20230506095504213"></p><h4 id="1-5-2-常量池"><a href="#1-5-2-常量池" class="headerlink" title="1.5.2 常量池"></a>1.5.2 常量池</h4><p>可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</p><p>查看字节码结构（类的基本信息、常量池、方法定义）<code>javap -v xx.class</code></p><p>比如下面是一个Application类的main方法执行，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到类对应的class文件存放目录，执行命令：<code>javap -v Application.class</code>   查看字节码结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">D:\code\jvm-demo\target\classes\com\heima\jvm&gt;javap -v Application.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Classfile</span> /D:/code/jvm-demo/target/classes/com/heima/jvm/Application.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2023</span>-<span class="number">05</span>-<span class="number">07</span>; size <span class="number">564</span> bytes    <span class="comment">//最后修改的时间</span></span><br><span class="line">  MD5 checksum c1b64ed6491b9a16c2baab5061c64f88   <span class="comment">//签名</span></span><br><span class="line">  Compiled from <span class="string">&quot;Application.java&quot;</span>   <span class="comment">//从哪个源码编译</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.heima.jvm.Application   <span class="comment">//包名，类名</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span>     <span class="comment">//jdk版本</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER  <span class="comment">//修饰符</span></span><br><span class="line">Constant pool:   <span class="comment">//常量池</span></span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">6.</span>#<span class="number">20</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">21.</span>#<span class="number">22</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">23</span>            <span class="comment">// hello world</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">24.</span>#<span class="number">25</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">26</span>            <span class="comment">// com/heima/jvm/Application</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">27</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">12</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               Lcom/heima/jvm/Application;</span><br><span class="line">  #<span class="number">14</span> = Utf8               main</span><br><span class="line">  #<span class="number">15</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">16</span> = Utf8               args</span><br><span class="line">  #<span class="number">17</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">18</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">19</span> = Utf8               Application.java</span><br><span class="line">  #<span class="number">20</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">21</span> = Class              #<span class="number">28</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">22</span> = NameAndType        #<span class="number">29</span>:#<span class="number">30</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">23</span> = Utf8               hello world</span><br><span class="line">  #<span class="number">24</span> = Class              #<span class="number">31</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">25</span> = NameAndType        #<span class="number">32</span>:#<span class="number">33</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">26</span> = Utf8               com/heima/jvm/Application</span><br><span class="line">  #<span class="number">27</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">28</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">29</span> = Utf8               out</span><br><span class="line">  #<span class="number">30</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">31</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">32</span> = Utf8               println</span><br><span class="line">  #<span class="number">33</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.heima.jvm.Application();  <span class="comment">//构造方法</span></span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/heima/jvm/Application;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;  <span class="comment">//main方法</span></span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String hello world</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Application.java&quot;</span></span><br></pre></td></tr></table></figure><p>下图，左侧是main方法的指令信息，右侧constant pool  是常量池</p><p>main方法按照指令执行的时候，需要到常量池中查表翻译找到具体的类和方法地址去执行</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218152.png" alt="image-20230506095634842"></p><h4 id="1-5-3-运行时常量池"><a href="#1-5-3-运行时常量池" class="headerlink" title="1.5.3 运行时常量池"></a>1.5.3 运行时常量池</h4><p>常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218153.png" alt="image-20230506100142724"></p><h3 id="1-6-你听过直接内存吗？"><a href="#1-6-你听过直接内存吗？" class="headerlink" title="1.6 你听过直接内存吗？"></a>1.6 你听过直接内存吗？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>不受 JVM 内存回收管理，是虚拟机的系统内存，常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理</p><p>举例：</p><p>需求，在本地电脑中的一个较大的文件（超过100m）从一个磁盘挪到另外一个磁盘</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218154.png" alt="image-20230506100501905"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 ByteBuffer 作用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_9</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FROM</span> <span class="operator">=</span> <span class="string">&quot;E:\\编程资料\\第三方教学视频\\youtube\\Getting Started with Spring Boot-sbPSjI4tt10.mp4&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TO</span> <span class="operator">=</span> <span class="string">&quot;E:\\a.mp4&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1Mb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        io(); <span class="comment">// io 用时：1535.586957 1766.963399 1359.240226</span></span><br><span class="line">        directBuffer(); <span class="comment">// directBuffer 用时：479.295165 702.291454 562.56592</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">directBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM).getChannel();</span><br><span class="line">             <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO).getChannel();</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1Mb);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> from.read(bb);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bb.flip();</span><br><span class="line">                to.write(bb);</span><br><span class="line">                bb.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;directBuffer 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">io</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM);</span><br><span class="line">             <span class="type">FileOutputStream</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO);</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[_1Mb];</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> from.read(buf);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                to.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;io 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，使用传统的IO的时间要比NIO操作的时间长了很多了，也就说NIO的读性能更好。</p><p>这个是跟我们的JVM的直接内存是有一定关系，如下图，是传统阻塞IO的数据传输流程</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218155.png" alt="image-20230506100548455"></p><p>下图是NIO传输数据的流程，在这个里面主要使用到了一个直接内存，不需要在堆中开辟空间进行数据的拷贝，jvm可以直接操作直接内存，从而使数据读写传输更快。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218156.png" alt="image-20230506100621146"></p><h3 id="1-7-堆栈的区别是什么？"><a href="#1-7-堆栈的区别是什么？" class="headerlink" title="1.7 堆栈的区别是什么？"></a>1.7 堆栈的区别是什么？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>1、栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。</p><p>2、栈内存是线程私有的，而堆内存是线程共有的。</p><p>3,、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。</p><p>栈空间不足：java.lang.StackOverFlowError。</p><p>堆空间不足：java.lang.OutOfMemoryError。</p><h2 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2 类加载器"></a>2 类加载器</h2><h3 id="2-1-什么是类加载器，类加载器有哪些"><a href="#2-1-什么是类加载器，类加载器有哪些" class="headerlink" title="2.1 什么是类加载器，类加载器有哪些?"></a>2.1 什么是类加载器，类加载器有哪些?</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>要想理解类加载器的话，务必要先清楚对于一个Java文件，它从编译到执行的整个过程。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218157.png"></p><ul><li>类加载器：用于装载字节码文件(.class文件)</li><li>运行时数据区：用于分配存储空间</li><li>执行引擎：执行字节码文件或本地方法</li><li>垃圾回收器：用于对JVM中的垃圾内容进行回收</li></ul><p><strong>类加载器</strong></p><p>JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来。现有的类加载器基本上都是java.lang.ClassLoader的子类，该类的只要职责就是用于将指定的类找到或生成对应的字节码文件，同时类加载器还会负责加载程序所需要的资源</p><p><strong>类加载器种类</strong></p><p>类加载器根据各自加载范围的不同，划分为四种类加载器：</p><ul><li><p><strong>启动类加载器(BootStrap ClassLoader)：</strong></p><p>该类并不继承ClassLoader类，其是由C++编写实现。用于加载<strong>JAVA_HOME&#x2F;jre&#x2F;lib</strong>目录下的类库。</p></li><li><p><strong>扩展类加载器(ExtClassLoader)：</strong></p><p>该类是ClassLoader的子类，主要加载<strong>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</strong>目录中的类库。</p></li><li><p><strong>应用类加载器(AppClassLoader)：</strong></p><p>该类是ClassLoader的子类，主要用于加载<strong>classPath</strong>下的类，也就是加载开发者自己编写的Java类。</p></li><li><p><strong>自定义类加载器：</strong></p><p>开发者自定义类继承ClassLoader，实现自定义类加载规则。</p></li></ul><p>上述三种类加载器的层次结构如下如下：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218158.png" alt="image-20230506100746624"></p><p>类加载器的体系并不是“继承”体系，而是<strong>委派体系</strong>，类加载器首先会到自己的parent中查找类或者资源，如果找不到才会到自己本地查找。类加载器的委托行为动机是为了避免相同的类被加载多次。</p><h3 id="2-2-什么是双亲委派模型？"><a href="#2-2-什么是双亲委派模型？" class="headerlink" title="2.2 什么是双亲委派模型？"></a>2.2 什么是双亲委派模型？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就返回成功；只有父类加载器无法完成此加载任务时，才由下一级去加载。 </p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218159.png" alt="image-20230506100920042"></p><h3 id="2-3-JVM为什么采用双亲委派机制"><a href="#2-3-JVM为什么采用双亲委派机制" class="headerlink" title="2.3 JVM为什么采用双亲委派机制"></a>2.3 JVM为什么采用双亲委派机制</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>（1）通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</p><p>（2）为了安全，保证类库API不会被修改</p><p>在工程中新建java.lang包，接着在该包下新建String类，并定义main函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;demo info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​此时执行main函数，会出现异常，在类 java.lang.String 中找不到 main 方法</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218160.png" alt="image-20220903144547378"></p><p>​出现该信息是因为由双亲委派的机制，java.lang.String的在启动类加载器(Bootstrap classLoader)得到加载，因为在核心jre库中有其相同名字的类文件，但该类中并没有main方法。这样就能防止恶意篡改核心API库。</p><h3 id="2-4-说一下类装载的执行过程？"><a href="#2-4-说一下类装载的执行过程？" class="headerlink" title="2.4 说一下类装载的执行过程？"></a>2.4 说一下类装载的执行过程？</h3><blockquote><p>难易程度：☆☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218161.png" alt="image-20230506101032605"></p><p><strong>类加载过程详解</strong></p><p>1.加载</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218162.png" alt="image-20230506101115674"> </p><ul><li><p>通过类的全名，获取类的二进制数据流。</p></li><li><p>解析类的二进制数据流为方法区内的数据结构（Java类模型） </p></li><li><p>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</p></li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218163.png" alt="image-20230506101213373"></p><p>2.验证</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218164.png" alt="image-20230506101420202"></p><p><strong>验证类是否符合JVM规范，安全性检查</strong></p><p>(1)文件格式验证:是否符合Class文件的规范<br>(2)元数据验证<br>    这个类是否有父类（除了Object这个类之外，其余的类都应该有父类）<br>    这个类是否继承（extends）了被final修饰过的类（被final修饰过的类表示类不能被继承）<br>    类中的字段、方法是否与父类产生矛盾。（被final修饰过的方法或字段是不能覆盖的）<br>(3)字节码验证<br>    主要的目的是通过对数据流和控制流的分析，确定程序语义是合法的、符合逻辑的。<br>(4)符号引用验证：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量</p><blockquote><p>比如：int i &#x3D; 3;<br>字面量：3<br>符号引用：i</p></blockquote><p>3.准备</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218165.png" alt="image-20230506101445898"></p><p><strong>为类变量分配内存并设置类变量初始值</strong></p><ul><li><p>static变量，分配空间在准备阶段完成（设置默认值），赋值在初始化阶段完成</p></li><li><p>static变量是final的基本类型，以及字符串常量，值已确定，赋值在准备阶段完成</p></li><li><p>static变量是final的引用类型，那么赋值也会在初始化阶段完成</p></li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218166.png" alt="image-20230506101824622"></p><p>4.解析</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218167.png" alt="image-20230506101504632"></p><p><strong>把类中的符号引用转换为直接引用</strong></p><p>比如：方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218168.png" alt="image-20230506102311951"></p><p>5.初始化</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218169.png" alt="image-20230506101625087"></p><p><strong>对类的静态变量，静态代码块执行初始化操作</strong></p><ul><li><p>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</p></li><li><p>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p></li></ul><p>6.使用</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218170.png" alt="image-20230506101641837"></p><p>JVM 开始从入口方法开始执行用户的程序代码</p><ul><li><p>调用静态类成员信息（比如：静态字段、静态方法）</p></li><li><p>使用new关键字为其创建对象实例</p></li></ul><p>7.卸载</p><p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存</p><h2 id="3-垃圾收回"><a href="#3-垃圾收回" class="headerlink" title="3 垃圾收回"></a>3 垃圾收回</h2><h3 id="3-1-简述Java垃圾回收机制？（GC是什么？为什么要GC）"><a href="#3-1-简述Java垃圾回收机制？（GC是什么？为什么要GC）" class="headerlink" title="3.1 简述Java垃圾回收机制？（GC是什么？为什么要GC）"></a>3.1 简述Java垃圾回收机制？（GC是什么？为什么要GC）</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。</p><p>有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。</p><p>在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机</p><p>换句话说，自动的垃圾回收的算法就会变得非常重要了，如果因为算法的不合理，导致内存资源一直没有释放，同样也可能会导致内存溢出的。</p><p>当然，除了Java语言，C#、Python等语言也都有自动的垃圾回收机制。</p><h3 id="3-2-对象什么时候可以被垃圾器回收"><a href="#3-2-对象什么时候可以被垃圾器回收" class="headerlink" title="3.2 对象什么时候可以被垃圾器回收"></a>3.2 对象什么时候可以被垃圾器回收</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218171.png" alt="image-20230506104954777"></p><p>简单一句就是：如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p><p>如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法</p><h4 id="3-2-1-引用计数法"><a href="#3-2-1-引用计数法" class="headerlink" title="3.2.1 引用计数法"></a>3.2.1 引用计数法</h4><p>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218172.png" alt="image-20230506111102825"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218173.png" alt="image-20230506111136231"></p><p>当对象间出现了循环引用的话，则引用计数法就会失效</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218174.png" alt="image-20230506111255401"></p><p>先执行右侧代码的前4行代码</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218175.png" alt="image-20230506111327590"></p><p>目前上方的引用关系和计数都是没问题的，但是，如果代码继续往下执行，如下图</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218176.png" alt="image-20230506111512450"></p><p>虽然a和b都为null，但是由于a和b存在循环引用，这样a和b永远都不会被回收。</p><p>优点：</p><ul><li>实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。</li><li>在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报OOM错误。</li><li>区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。</li></ul><p>缺点：</p><ul><li>每次对象被引用时，都需要去更新计数器，有一点时间开销。 </li><li><strong>浪费CPU资源</strong>，即使内存够用，仍然在运行时进行计数器的统计。</li><li><strong>无法解决循环引用问题，会引发内存泄露</strong>。（最大的缺点）</li></ul><h4 id="3-2-2-可达性分析算法"><a href="#3-2-2-可达性分析算法" class="headerlink" title="3.2.2 可达性分析算法"></a>3.2.2 可达性分析算法</h4><p>​现在的虚拟机采用的都是通过可达性分析算法来确定哪些内容是垃圾。</p><p>​会存在一个根节点【GC Roots】，引出它下面指向的下一个节点，再以下一个节点节点开始找出它下面的节点，依次往下类推。直到所有的节点全部遍历完毕。</p><blockquote><p>根对象是那些肯定不能当做垃圾回收的对象，就可以当做根对象</p><p>局部变量，静态方法，静态变量，类信息</p><p>核心是：判断某对象是否与根对象有直接或间接的引用，如果没有被引用，则可以当做垃圾回收</p></blockquote><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218177.png" alt="image-20220904010634153"></p><p>​X,Y这两个节点是可回收的，但是<strong>并不会马上的被回收！！</strong> 对象中存在一个方法【finalize】。当对象被标记为可回收后，当发生GC时，首先<strong>会判断这个对象是否执行了finalize方法</strong>，如果这个方法还没有被执行的话，那么就会先来执行这个方法，接着在这个方法执行中，可以设置当前这个对象与GC ROOTS产生关联，那么这个方法执行完成之后，GC会再次判断对象是否可达，如果仍然不可达，则会进行回收，如果可达了，则不会进行回收。</p><p>​finalize方法对于每一个对象来说，只会执行一次。如果第一次执行这个方法的时候，设置了当前对象与RC ROOTS关联，那么这一次不会进行回收。 那么等到这个对象第二次被标记为可回收时，那么该对象的finalize方法就不会再次执行了。</p><p><strong>GC ROOTS：</strong></p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * demo是栈帧中的本地变量，当 demo = null 时，由于此时 demo 充当了 GC Root 的作用，demo与原来指向的实例 new Demo() 断开了连接，对象被回收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">    demo = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法区中类静态属性引用的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当栈帧中的本地变量 b = null 时，由于 b 原来指向的对象与 GC Root (变量 b) 断开了连接，所以 b 原来指向的对象会被回收，而由于我们给 a 赋值了变量的引用，a在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Demo a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        b.a = <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        b = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法区中常量引用的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常量 a 指向的对象并不会因为 demo 指向的对象被回收而回收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Demo</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        demo = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul><h3 id="3-3-JVM-垃圾回收算法有哪些？"><a href="#3-3-JVM-垃圾回收算法有哪些？" class="headerlink" title="3.3 JVM 垃圾回收算法有哪些？"></a>3.3 JVM 垃圾回收算法有哪些？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><h4 id="3-3-1-标记清除算法"><a href="#3-3-1-标记清除算法" class="headerlink" title="3.3.1 标记清除算法"></a>3.3.1 标记清除算法</h4><p>标记清除算法，是将垃圾回收分为2个阶段，分别是<strong>标记和清除</strong>。</p><p>1.根据可达性分析算法得出的垃圾进行标记</p><p>2.对这些标记为可回收的内容进行垃圾回收</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218178.png" alt="image-20230506112047190"></p><p>可以看到，标记清除算法解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被回收。</p><p>同样，标记清除算法也是有缺点的：</p><ul><li>效率较低，<strong>标记和清除两个动作都需要遍历所有的对象</strong>，并且在GC时，<strong>需要停止应用程序</strong>，对于交互性要求比较高的应用而言这个体验是非常差的。</li><li>（<strong>重要</strong>）通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。</li></ul><h4 id="3-3-2-复制算法"><a href="#3-3-2-复制算法" class="headerlink" title="3.3.2 复制算法"></a>3.3.2 复制算法</h4><p>​复制算法的核心就是，<strong>将原有的内存空间一分为二，每次只用其中的一块</strong>，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。</p><p>​如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之，则不适合。 </p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218179.png" alt="image-20230506111919008"></p><p>1）将内存区域分成两部分，每次操作其中一个。</p><p>2）当进行垃圾回收时，将正在使用的内存区域中的存活对象移动到未使用的内存区域。当移动完对这部分内存区域一次性清除。</p><p>3）周而复始。</p><p>优点：</p><ul><li>在垃圾对象多的情况下，效率较高</li><li>清理后，内存无碎片</li></ul><p>缺点：</p><ul><li>分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低</li></ul><h4 id="3-3-3-标记整理算法"><a href="#3-3-3-标记整理算法" class="headerlink" title="3.3.3 标记整理算法"></a>3.3.3 标记整理算法</h4><p>​标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的直接清理可回收对象，而是将存活对象都向内存另一端移动，然后清理边界以外的垃圾，从而解决了碎片化的问题。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218180.png" alt="image-20230506111957793"></p><p>1）标记垃圾。</p><p>2）需要清除向右边走，不需要清除的向左边走。</p><p>3）清除边界以外的垃圾。</p><p>优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有有一定的影响。</p><p>与复制算法对比：复制算法标记完就复制，但标记整理算法得等把所有存活对象都标记完毕，再进行整理</p><h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h3><h4 id="3-4-1-概述"><a href="#3-4-1-概述" class="headerlink" title="3.4.1 概述"></a>3.4.1 概述</h4><p>在java8时，堆被分为了两份：<strong>新生代和老年代【1：2】</strong>，在java7时，还存在一个永久代。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218181.png" alt="image-20230506131229649"></p><p>对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区【8：1：1】</p><p>当对新生代产生GC：MinorGC【young GC】</p><p>当对老年代代产生GC：Major GC </p><p>当对新生代和老年代产生FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p><h4 id="3-4-2工作机制"><a href="#3-4-2工作机制" class="headerlink" title="3.4.2工作机制"></a>3.4.2工作机制</h4><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218182.png" alt="image-20230506131308654"></p><ul><li>新创建的对象，都会先分配到eden区</li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218183.png" alt="image-20230506131415418"></p><ul><li><p>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</p></li><li><p>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</p></li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218184.png" alt="image-20230506131442503"></p><ul><li>经过一段时间后伊甸园的内存又出现不足，标记eden区域to区存活的对象，将存活的对象复制到from区</li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218185.png" alt="image-20230506131544447"></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218186.png" alt="image-20230506131607645"></p><ul><li>当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li></ul><p><strong>MinorGC、 Mixed GC 、 FullGC的区别是什么</strong></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218187.png" alt="image-20230506131640893"></p><ul><li><p>MinorGC【young GC】发生在新生代的垃圾回收，暂停时间短（STW）</p></li><li><p>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</p></li><li><p>FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长（STW），应尽力避免？</p></li></ul><blockquote><p>名词解释：</p><p>STW（Stop-The-World）：暂停所有应用程序线程，等待垃圾回收的完成</p></blockquote><h3 id="3-5-说一下-JVM-有哪些垃圾回收器？"><a href="#3-5-说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="3.5 说一下 JVM 有哪些垃圾回收器？"></a>3.5 说一下 JVM 有哪些垃圾回收器？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>在jvm中，实现了多种垃圾收集器，包括：</p><ul><li><p>串行垃圾收集器</p></li><li><p>并行垃圾收集器</p></li><li><p>CMS（并发）垃圾收集器</p></li><li><p>G1垃圾收集器</p></li></ul><h4 id="3-5-1-串行垃圾收集器"><a href="#3-5-1-串行垃圾收集器" class="headerlink" title="3.5.1 串行垃圾收集器"></a>3.5.1 串行垃圾收集器</h4><p>Serial和Serial Old串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑</p><ul><li><p>Serial 作用于新生代，采用复制算法</p></li><li><p>Serial Old 作用于老年代，采用标记-整理算法</p></li></ul><p>垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218189.png" alt="image-20230506154006266"></p><h4 id="3-5-2-并行垃圾收集器"><a href="#3-5-2-并行垃圾收集器" class="headerlink" title="3.5.2 并行垃圾收集器"></a>3.5.2 并行垃圾收集器</h4><p>Parallel New和Parallel Old是一个并行垃圾回收器，<strong>JDK8默认使用此垃圾回收器</strong></p><ul><li><p>Parallel New作用于新生代，采用复制算法</p></li><li><p>Parallel Old作用于老年代，采用标记-整理算法</p></li></ul><p>垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218190.png" alt="image-20230506154042673"></p><h4 id="3-5-2-CMS（并发）垃圾收集器"><a href="#3-5-2-CMS（并发）垃圾收集器" class="headerlink" title="3.5.2 CMS（并发）垃圾收集器"></a>3.5.2 CMS（并发）垃圾收集器</h4><p>CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218191.png" alt="image-20230506154117857"></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218192.png" alt="image-20230506154107944"></p><h3 id="3-6-详细聊一下G1垃圾回收器"><a href="#3-6-详细聊一下G1垃圾回收器" class="headerlink" title="3.6 详细聊一下G1垃圾回收器"></a>3.6 详细聊一下G1垃圾回收器</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><h4 id="3-6-1-概述"><a href="#3-6-1-概述" class="headerlink" title="3.6.1 概述"></a>3.6.1 概述</h4><ul><li><p>应用于新生代和老年代，<strong>在<strong><strong>JDK9</strong></strong>之后默认使用****G1</strong></p></li><li><p>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</p></li><li><p>采用复制算法</p></li><li><p>响应时间与吞吐量兼顾</p></li><li><p>分成三个阶段：新生代回收、并发标记、混合收集</p></li><li><p>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</p></li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218193.png" alt="image-20230506154323950"></p><h4 id="3-6-2-Young-Collection-年轻代垃圾回收"><a href="#3-6-2-Young-Collection-年轻代垃圾回收" class="headerlink" title="3.6.2 Young Collection(年轻代垃圾回收)"></a>3.6.2 Young Collection(年轻代垃圾回收)</h4><ul><li><p>初始时，所有区域都处于空闲状态</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218194.png" alt="image-20230506154542687"></p></li><li><p>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218195.png" alt="image-20230506154607558"></p></li><li><p>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218196.png" alt="image-20230506154633118"></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218197.png" alt="image-20230506154705088"></p></li><li><p>随着时间流逝，伊甸园的内存又有不足</p></li><li><p>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218198.png" alt="image-20230506154759809"></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218199.png" alt="image-20230506154826981"></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218200.png" alt="image-20230506154859985"></p></li></ul><h4 id="3-6-3-Young-Collection-Concurrent-Mark-年轻代垃圾回收-并发标记"><a href="#3-6-3-Young-Collection-Concurrent-Mark-年轻代垃圾回收-并发标记" class="headerlink" title="3.6.3 Young Collection + Concurrent Mark (年轻代垃圾回收+并发标记)"></a>3.6.3 Young Collection + Concurrent Mark (年轻代垃圾回收+并发标记)</h4><p>当老年代占用内存超过阈值(默认是45%)后，触发并发标记，这时无需暂停用户线程</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218201.png" alt="image-20230506155000503"></p><ul><li><p>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。</p></li><li><p>这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据暂停时间目标优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218202.png" alt="image-20230506155047765"></p></li></ul><h4 id="3-6-4-Mixed-Collection-混合垃圾回收"><a href="#3-6-4-Mixed-Collection-混合垃圾回收" class="headerlink" title="3.6.4 Mixed Collection (混合垃圾回收)"></a>3.6.4 Mixed Collection (混合垃圾回收)</h4><p>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218203.png" alt="image-20230506155116267"></p><p>其中H叫做巨型对象，如果对象非常大，会开辟一块连续的空间存储巨型对象</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218204.png" alt="image-20230506155146370"></p><h3 id="3-7-强引用、软引用、弱引用、虚引用的区别？"><a href="#3-7-强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="3.7 强引用、软引用、弱引用、虚引用的区别？"></a>3.7 强引用、软引用、弱引用、虚引用的区别？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><h4 id="3-7-1-强引用"><a href="#3-7-1-强引用" class="headerlink" title="3.7.1 强引用"></a>3.7.1 强引用</h4><p>强引用：只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br></pre></td></tr></table></figure><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218205.png" alt="image-20230506155341703"></p><h4 id="3-7-2-软引用"><a href="#3-7-2-软引用" class="headerlink" title="3.7.2 软引用"></a>3.7.2 软引用</h4><p>软引用：仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">SoftReference</span> <span class="variable">softReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftReference</span>(user);</span><br></pre></td></tr></table></figure><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218206.png" alt="image-20230506155416293"></p><h4 id="3-7-3-弱引用"><a href="#3-7-3-弱引用" class="headerlink" title="3.7.3 弱引用"></a>3.7.3 弱引用</h4><p>弱引用：仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">WeakReference</span> <span class="variable">weakReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(user);</span><br></pre></td></tr></table></figure><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218207.png" alt="image-20230506155501557"></p><blockquote><p>延伸话题：ThreadLocal内存泄漏问题</p></blockquote><p>ThreadLocal用的就是弱引用，看以下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">         <span class="built_in">super</span>(k);</span><br><span class="line">         value = v; <span class="comment">//强引用，不会被回收</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Entry</code>的key是当前ThreadLocal，value值是我们要设置的数据。</p><p><code>WeakReference</code>表示的是弱引用，当JVM进行GC时，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存。但是<code>value</code>是强引用，它不会被回收掉。</p><blockquote><p>ThreadLocal使用建议：使用完毕后注意调用清理方法。</p></blockquote><h4 id="3-7-4-虚引用"><a href="#3-7-4-虚引用" class="headerlink" title="3.7.4 虚引用"></a>3.7.4 虚引用</h4><p>虚引用：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218208.png" alt="image-20230506155518510"></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218209.png" alt="image-20230506155552693"></p><h2 id="4-JVM实践（调优）"><a href="#4-JVM实践（调优）" class="headerlink" title="4 JVM实践（调优）"></a>4 JVM实践（调优）</h2><h3 id="4-1-JVM-调优的参数可以在哪里设置参数值？"><a href="#4-1-JVM-调优的参数可以在哪里设置参数值？" class="headerlink" title="4.1 JVM 调优的参数可以在哪里设置参数值？"></a>4.1 JVM 调优的参数可以在哪里设置参数值？</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆☆</p></blockquote><h4 id="4-1-1-tomcat的设置vm参数"><a href="#4-1-1-tomcat的设置vm参数" class="headerlink" title="4.1.1 tomcat的设置vm参数"></a>4.1.1 tomcat的设置vm参数</h4><p>修改TOMCAT_HOME&#x2F;bin&#x2F;catalina.sh文件，如下图</p><p><code>JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot; </code></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218210.png" alt="image-20220904151948778"></p><h4 id="4-1-2-springboot项目jar文件启动"><a href="#4-1-2-springboot项目jar文件启动" class="headerlink" title="4.1.2 springboot项目jar文件启动"></a>4.1.2 springboot项目jar文件启动</h4><p>通常在linux系统下直接加参数启动springboot项目</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> java -Xms512m -Xmx1024m -jar xxxx.jar --spring.profiles.active=prod &amp;</span><br></pre></td></tr></table></figure><blockquote><p>nohup  :  用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行</p><p>参数 <strong>&amp;</strong>  ：让命令在后台执行，终端退出后命令仍旧执行。</p></blockquote><h3 id="4-2-用的-JVM-调优的参数都有哪些？"><a href="#4-2-用的-JVM-调优的参数都有哪些？" class="headerlink" title="4.2 用的 JVM 调优的参数都有哪些？"></a>4.2 用的 JVM 调优的参数都有哪些？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>​对于JVM调优，主要就是调整年轻代、年老大、元空间的内存空间大小及使用的垃圾回收器类型。</p><p><a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html">https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</a></p><p>1）设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xms：设置堆的初始化大小</span><br><span class="line"></span><br><span class="line">-Xmx：设置堆的最大大小</span><br></pre></td></tr></table></figure><p>2） 设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8:1:1。Java官方通过增大Eden区的大小，来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满</p><p>的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XXSurvivorRatio=3，表示年轻代中的分配比率：survivor:eden = 2:3</span><br></pre></td></tr></table></figure><p>3）年轻代和老年代默认比例为1：2。可以通过调整二者空间大小比率来设置两者的大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:newSize   设置年轻代的初始大小</span><br><span class="line">-XX:MaxNewSize   设置年轻代的最大大小，  初始大小和最大大小两个值通常相同</span><br></pre></td></tr></table></figure><p>4）线程堆栈的设置：<strong>每个线程默认会开启1M的堆栈</strong>，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss   对每个线程stack大小的调整,-Xss128k</span><br></pre></td></tr></table></figure><p>5）一般来说，当survivor区不够大或者占用量达到50%，就会把一些对象放到老年区。通过设置合理的eden区，survivor区及使用率，可以将年轻对象保存在年轻代，从而避免full GC，使用-Xmn设置年轻代的大小</p><p>6）系统CPU持续飙高的话，首先先排查代码问题，如果代码没问题，则咨询运维或者云服务器供应商，通常服务器重启或者服务器迁移即可解决。</p><p>7）对于占用内存比较多的大对象，一般会选择在老年代分配内存。如果在年轻代给大对象分配内存，年轻代内存不够了，就要在eden区移动大量对象到老年代，然后这些移动的对象可能很快消亡，因此导致full GC。通过设置参数：-XX:PetenureSizeThreshold&#x3D;1000000，单位为B，标明对象大小超过1M时，在老年代(tenured)分配内存空间。</p><p>8）一般情况下，年轻对象放在eden区，当第一次GC后，如果对象还存活，放到survivor区，此后，每GC一次，年龄增加1，当对象的年龄达到阈值，就被放到tenured老年区。这个阈值可以同构-XX:MaxTenuringThreshold设置。如果想让对象留在年轻代，可以设置比较大的阈值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）-XX:+UseParallelGC:年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能的减少垃圾回收时间。</span><br><span class="line"></span><br><span class="line">（2）-XX:+UseParallelOldGC:设置老年代使用并行垃圾回收收集器。</span><br></pre></td></tr></table></figure><p>9）尝试使用大的内存分页：使用大的内存分页增加CPU的内存寻址能力，从而系统的性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+LargePageSizeInBytes 设置内存页的大小</span><br></pre></td></tr></table></figure><p>10）使用非占用的垃圾收集器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC老年代使用CMS收集器降低停顿。</span><br></pre></td></tr></table></figure><h3 id="4-3-说一下-JVM-调优的工具？"><a href="#4-3-说一下-JVM-调优的工具？" class="headerlink" title="4.3 说一下 JVM 调优的工具？"></a>4.3 说一下 JVM 调优的工具？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><h4 id="4-3-1-命令工具"><a href="#4-3-1-命令工具" class="headerlink" title="4.3.1 命令工具"></a>4.3.1 命令工具</h4><h5 id="4-3-1-1-jps（Java-Process-Status）"><a href="#4-3-1-1-jps（Java-Process-Status）" class="headerlink" title="4.3.1.1 jps（Java Process Status）"></a>4.3.1.1 jps（Java Process Status）</h5><p>输出JVM中运行的进程状态信息(现在一般使用jconsole)</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218211.png" alt="image-20220904104739581"></p><h5 id="4-3-1-2-jstack"><a href="#4-3-1-2-jstack" class="headerlink" title="4.3.1.2 jstack"></a>4.3.1.2 jstack</h5><p>查看java进程内<strong>线程的堆栈</strong>信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] &lt;pid&gt;  </span><br></pre></td></tr></table></figure><p>java案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;哈哈哈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用jstack查看进行堆栈运行信息</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218212.png" alt="image-20220904111059602"></p><h5 id="4-3-1-3-jmap"><a href="#4-3-1-3-jmap" class="headerlink" title="4.3.1.3 jmap"></a>4.3.1.3 jmap</h5><p>用于生成堆转存快照</p><blockquote><p>jmap [options] pid  内存映像信息</p><p>jmap -heap pid   显示Java堆的信息</p><p>jmap -dump:format&#x3D;b,file&#x3D;heap.hprof pid</p><p>​format&#x3D;b表示以hprof二进制格式转储Java堆的内存<br>​file&#x3D;<filename>用于指定快照dump文件的文件名。</p></blockquote><p>例：显示了某一个java运行的堆信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\yuhon&gt;jmap -heap <span class="number">53280</span></span><br><span class="line">Attaching to process ID <span class="number">53280</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.321</span>-b07</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with <span class="number">8</span> thread(s)   <span class="comment">//并行的垃圾回收器</span></span><br><span class="line"></span><br><span class="line">Heap Configuration:  <span class="comment">//堆配置</span></span><br><span class="line">   MinHeapFreeRatio         = <span class="number">0</span>   <span class="comment">//空闲堆空间的最小百分比</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">100</span>  <span class="comment">//空闲堆空间的最大百分比</span></span><br><span class="line">   MaxHeapSize              = <span class="number">8524922880</span> (<span class="number">8130.</span>0MB) <span class="comment">//堆空间允许的最大值</span></span><br><span class="line">   NewSize                  = <span class="number">178257920</span> (<span class="number">170.</span>0MB) <span class="comment">//新生代堆空间的默认值</span></span><br><span class="line">   MaxNewSize               = <span class="number">2841640960</span> (<span class="number">2710.</span>0MB) <span class="comment">//新生代堆空间允许的最大值</span></span><br><span class="line">   OldSize                  = <span class="number">356515840</span> (<span class="number">340.</span>0MB) <span class="comment">//老年代堆空间的默认值</span></span><br><span class="line">   NewRatio                 = <span class="number">2</span> <span class="comment">//新生代与老年代的堆空间比值，表示新生代：老年代=1：2</span></span><br><span class="line">   SurvivorRatio            = <span class="number">8</span> <span class="comment">//两个Survivor区和Eden区的堆空间比值为8,表示S0:S1:Eden=1:1:8</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.</span>796875MB) <span class="comment">//元空间的默认值</span></span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.</span>0MB) <span class="comment">//压缩类使用空间大小</span></span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> MB <span class="comment">//元空间允许的最大值</span></span><br><span class="line">   G1HeapRegionSize         = <span class="number">0</span> (<span class="number">0.</span>0MB)<span class="comment">//在使用 G1 垃圾回收算法时，JVM 会将 Heap 空间分隔为若干个 Region，该参数用来指定每个 Region 空间的大小。</span></span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space: <span class="comment">//Eden使用情况</span></span><br><span class="line">   capacity = <span class="number">134217728</span> (<span class="number">128.</span>0MB)</span><br><span class="line">   used     = <span class="number">10737496</span> (<span class="number">10.</span>240074157714844MB)</span><br><span class="line">   free     = <span class="number">123480232</span> (<span class="number">117.</span>75992584228516MB)</span><br><span class="line">   <span class="number">8.000057935714722</span>% used</span><br><span class="line">From Space: <span class="comment">//Survivor-From 使用情况</span></span><br><span class="line">   capacity = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">To Space: <span class="comment">//Survivor-To 使用情况</span></span><br><span class="line">   capacity = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">PS Old Generation  <span class="comment">//老年代 使用情况</span></span><br><span class="line">   capacity = <span class="number">356515840</span> (<span class="number">340.</span>0MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">356515840</span> (<span class="number">340.</span>0MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line"></span><br><span class="line"><span class="number">3185</span> interned Strings occupying <span class="number">261264</span> bytes.</span><br></pre></td></tr></table></figure><h5 id="4-3-1-4-jhat"><a href="#4-3-1-4-jhat" class="headerlink" title="4.3.1.4 jhat"></a>4.3.1.4 jhat</h5><p>用于分析jmap生成的堆转存快照（一般不推荐使用，而是使用Ecplise Memory Analyzer）</p><h5 id="4-3-1-5-jstat"><a href="#4-3-1-5-jstat" class="headerlink" title="4.3.1.5 jstat"></a>4.3.1.5 jstat</h5><p>是JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。</p><p><strong>常见参数</strong>：</p><p>①总结垃圾回收统计</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil pid</span><br></pre></td></tr></table></figure><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218213.png" alt="image-20220904114511854"></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>S0</td><td>幸存1区当前使用比例</td></tr><tr><td>S1</td><td>幸存2区当前使用比例</td></tr><tr><td>E</td><td>伊甸园区使用比例</td></tr><tr><td>O</td><td>老年代使用比例</td></tr><tr><td>M</td><td>元数据区使用比例</td></tr><tr><td>CCS</td><td>压缩使用比例</td></tr><tr><td>YGC</td><td>年轻代垃圾回收次数</td></tr><tr><td>YGCT</td><td>年轻代垃圾回收消耗时间</td></tr><tr><td>FGC</td><td>老年代垃圾回收次数</td></tr><tr><td>FGCT</td><td>老年代垃圾回收消耗时间</td></tr><tr><td>GCT</td><td>垃圾回收消耗总时间</td></tr></tbody></table><p>②垃圾回收统计</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc pid</span><br></pre></td></tr></table></figure><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218214.png" alt="image-20220904115157363"></p><h4 id="4-3-2-可视化工具"><a href="#4-3-2-可视化工具" class="headerlink" title="4.3.2 可视化工具"></a>4.3.2 可视化工具</h4><h5 id="4-3-2-1-jconsole"><a href="#4-3-2-1-jconsole" class="headerlink" title="4.3.2.1 jconsole"></a>4.3.2.1 jconsole</h5><p>用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具</p><p>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218215.png" alt="image-20220904115936095"></p><p>可以内存、线程、类等信息</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218216.png" alt="image-20220904120057211"></p><h5 id="4-3-2-2-VisualVM：故障处理工具"><a href="#4-3-2-2-VisualVM：故障处理工具" class="headerlink" title="4.3.2.2 VisualVM：故障处理工具"></a>4.3.2.2 VisualVM：故障处理工具</h5><p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈</p><p>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218217.png" alt="image-20220904120356174"></p><p>监控程序运行情况</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218218.png" alt="image-20220904132011289"></p><p>查看运行中的dump</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218219.png" alt="image-20220904132134095"></p><p>查看堆中的信息</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218220.png" alt="image-20220904132346495"></p><h3 id="4-4-java内存泄露的排查思路？"><a href="#4-4-java内存泄露的排查思路？" class="headerlink" title="4.4 java内存泄露的排查思路？"></a>4.4 java内存泄露的排查思路？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>原因：</p><p>如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量的时候，java虚拟机将抛出一个StackOverFlowError异常</p><p>如果java虚拟机栈可以动态拓展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成拓展，或者在建立新线程的时候没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个OutOfMemoryError异常</p><p>如果一次加载的类太多，元空间内存不足，则会报OutOfMemoryError: Metaspace</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218221.png" alt="image-20230506155704119"></p><p>1、通过jmap指定打印他的内存快照 dump</p><blockquote><p>有的情况是内存溢出之后程序则会直接中断，而jmap只能打印在运行中的程序，所以建议通过参数的方式的生成dump文件，配置如下：</p><p>-XX:+HeapDumpOnOutOfMemoryError<br>-XX:HeapDumpPath&#x3D;&#x2F;home&#x2F;app&#x2F;dumps&#x2F;      指定生成后文件的保存目录</p></blockquote><p>2、通过工具， VisualVM（Ecplise MAT）去分析 dump文件</p><p>VisualVM可以加载离线的dump文件，如下图</p><p>文件–&gt;装入—&gt;选择dump文件即可查看堆快照信息</p><blockquote><p>如果是linux系统中的程序，则需要把dump文件下载到本地（windows环境）下，打开VisualVM工具分析。VisualVM目前只支持在windows环境下运行可视化</p></blockquote><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218222.png" alt="image-20220904132925812"></p><p>3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218223.png" alt="image-20220904133722905"></p><p>4、找到对应的代码，通过阅读上下文的情况，进行修复即可</p><h3 id="4-5-CPU飙高排查方案与思路？"><a href="#4-5-CPU飙高排查方案与思路？" class="headerlink" title="4.5 CPU飙高排查方案与思路？"></a>4.5 CPU飙高排查方案与思路？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>1.使用top命令查看占用cpu的情况</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218224.png" alt="image-20220904161818255"></p><p>2.通过top命令查看后，可以查看是哪一个进程占用cpu较高，上图所示的进程为：30978</p><p>3.查看当前线程中的进程信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps H -eo pid,tid,%cpu | grep 40940</span><br></pre></td></tr></table></figure><blockquote><p>pid  进行id</p><p>tid   进程中的线程id</p><p>%  cpu使用率 </p></blockquote><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218225.png" alt="image-20220904162117022"></p><p>4.通过上图分析，在进程30978中的线程30979占用cpu较高</p><blockquote><p>注意：上述的线程id是一个十进制，我们需要把这个线程id转换为16进制才行，因为通常在日志中展示的都是16进制的线程id名称</p><p>转换方式：</p><p>在linux中执行命令</p><p><code>printf &quot;%x\n&quot; 30979</code></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218226.png" alt="image-20220904162654928"></p></blockquote><p>5.可以根据线程 id 找到有问题的线程，进一步定位到问题代码的源码行号</p><p>执行命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 30978   此处是进程<span class="built_in">id</span></span><br></pre></td></tr></table></figure><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211218227.png" alt="image-20220904162941977"></p><h2 id="5-面试现场"><a href="#5-面试现场" class="headerlink" title="5.面试现场"></a>5.面试现场</h2><h3 id="5-1-JVM组成"><a href="#5-1-JVM组成" class="headerlink" title="5.1 JVM组成"></a>5.1 JVM组成</h3><blockquote><p><strong>面试官</strong>：JVM由那些部分组成，运行流程是什么？</p><p><strong>候选人:</strong></p><p>嗯，好的~~</p><p>在JVM中共有四大部分，分别是ClassLoader（类加载器）、Runtime Data Area（运行时数据区，内存分区）、Execution Engine（执行引擎）、Native Method Library（本地库接口）</p><p>它们的运行流程是：</p><p>第一，类加载器（ClassLoader）把Java代码转换为字节码</p><p>第二，运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行</p><p>第三，执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。</p><p><strong>面试官</strong>：好的，你能详细说一下 JVM 运行时数据区吗？</p><p><strong>候选人:</strong></p><p>嗯，好~</p><p>运行时数据区包含了堆、方法区、栈、本地方法栈、程序计数器这几部分，每个功能作用不一样。</p><ul><li>堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。</li><li>方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。</li><li>栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。</li><li>本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。</li><li>程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</li></ul><p><strong>面试官</strong>：好的，你再详细介绍一下程序计数器的作用？</p><p><strong>候选人:</strong></p><p>嗯，是这样~~</p><p>java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。这时候程序计数器就起到了关键作用，程序计数器在来回切换的线程中记录他上一次执行的行号，然后接着继续向下执行。</p><p><strong>面试官</strong>：你能给我详细的介绍Java堆吗?</p><p><strong>候选人:</strong></p><p>好的~</p><p>Java中的堆术语线程共享的区域。主要用来保存<strong>对象实例，数组</strong>等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。</p><p>​在JAVA8中堆内会存在年轻代、老年代</p><p>​1）Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用。在Eden区变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。</p><p>​2）Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区。</p><p><strong>面试官</strong>：能不能解释一下方法区？</p><p><strong>候选人:</strong></p><p>好的~</p><p>与虚拟机栈类似。本地方法栈是为虚拟机<strong>执行本地方法时提供服务的</strong>。不需要进行GC。本地方法一般是由其他语言编写。</p><p><strong>面试官</strong>：你听过直接内存吗？</p><p><strong>候选人:</strong></p><p>嗯~~</p><p>它又叫做<strong>堆外内存</strong>，<strong>线程共享的区域</strong>，在 Java 8 之前有个<strong>永久代</strong>的概念，实际上指的是 HotSpot 虚拟机上的永久代，它用永久代实现了 JVM 规范定义的方法区功能，<strong>主要存储类的信息，常量，静态变量</strong>，即时编译器编译后代码等，这部分由于是在堆中实现的，受 GC 的管理，不过由于永久代有 -XX:MaxPermSize 的上限，所以如果大量动态生成类（将类信息放入永久代），很容易造成 OOM，有人说可以把永久代设置得足够大，但很难确定一个合适的大小，受类数量，常量数量的多少影响很大。</p><p>​所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了,也就不会进行 GC，也因此提升了性能。</p><p><strong>面试官</strong>：什么是虚拟机栈</p><p><strong>候选人:</strong></p><p>虚拟机栈是描述的是方法执行时的内存模型,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建<strong>栈桢</strong>。保存执行方法时的<strong>局部变量、动态连接信息、方法返回地址信息</strong>等等。方法开始执行的时候会进栈，方法执行完会出栈【相当于清空了数据】，所以这块区域<strong>不需要进行 GC</strong>。</p><p><strong>面试官</strong>：能说一下堆栈的区别是什么吗？</p><p><strong>候选人:</strong></p><p>嗯，好的，有这几个区别</p><p>第一，栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。</p><p>第二、栈内存是线程私有的，而堆内存是线程共有的。</p><p>第三、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。</p><p>栈空间不足：java.lang.StackOverFlowError。</p><p>堆空间不足：java.lang.OutOfMemoryError。</p></blockquote><h3 id="5-2-类加载器"><a href="#5-2-类加载器" class="headerlink" title="5.2 类加载器"></a>5.2 类加载器</h3><blockquote><p><strong>面试官</strong>：什么是类加载器，类加载器有哪些?</p><p><strong>候选人:</strong></p><p>嗯，是这样的</p><p>JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来。</p><p>常见的类加载器有4个</p><p>第一个是启动类加载器(BootStrap ClassLoader)：其是由C++编写实现。用于加载JAVA_HOME&#x2F;jre&#x2F;lib目录下的类库。</p><p>第二个是扩展类加载器(ExtClassLoader)：该类是ClassLoader的子类，主要加载JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext目录中的类库。</p><p>第三个是应用类加载器(AppClassLoader)：该类是ClassLoader的子类，主要用于加载classPath下的类，也就是加载开发者自己编写的Java类。</p><p>第四个是自定义类加载器：开发者自定义类继承ClassLoader，实现自定义类加载规则。</p><p><strong>面试官</strong>：说一下类装载的执行过程？</p><p><strong>候选人:</strong></p><p>嗯，这个过程还是挺多的。</p><p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）</p><p>1.加载：查找和导入class文件</p><p>2.验证：保证加载类的准确性</p><p>3.准备：为类变量分配内存并设置类变量初始值</p><p>4.解析：把类中的符号引用转换为直接引用</p><p>5.初始化：对类的静态变量，静态代码块执行初始化操作</p><p>6.使用：JVM 开始从入口方法开始执行用户的程序代码</p><p>7.卸载：当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存</p><p><strong>面试官</strong>：什么是双亲委派模型？</p><p><strong>候选人:</strong></p><p>嗯，它是是这样的。</p><p>如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传说到顶层的启动类加载器中，只有当父类加载器返回自己无法完成这个加载请求（它的搜索返回中没有找到所需的类）时，子类加载器才会尝试自己去加载</p><p><strong>面试官</strong>：JVM为什么采用双亲委派机制</p><p><strong>候选人:</strong></p><p>主要有两个原因。</p><p>第一、通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</p><p>第二、为了安全，保证类库API不会被修改</p></blockquote><h3 id="5-3-垃圾回收"><a href="#5-3-垃圾回收" class="headerlink" title="5.3 垃圾回收"></a>5.3 垃圾回收</h3><blockquote><p><strong>面试官</strong>：简述Java垃圾回收机制？（GC是什么？为什么要GC）</p><p><strong>候选人:</strong></p><p>嗯，是这样~~</p><p>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。</p><p>有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。</p><p>在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机</p><p><strong>面试官</strong>：强引用、软引用、弱引用、虚引用的区别？</p><p><strong>候选人:</strong></p><p>嗯嗯~</p><p>强引用最为普通的引用方式，表示一个对象处于<strong>有用且必须</strong>的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收</p><p>软引用表示一个对象处于<strong>有用且非必须</strong>状态，如果一个对象处于软引用，在内存空间足够的情况下，GC机制并不会回收它，而在内存空间不足时，则会在OOM异常出现之间对其进行回收。但值得注意的是，因为GC线程优先级较低，软引用并不会立即被回收。</p><p>弱引用表示一个对象处于<strong>可能有用且非必须</strong>的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收。同样的，因为GC线程优先级较低，所以弱引用也并不是会被立刻回收。</p><p>虚引用表示一个对象处于<strong>无用</strong>的状态。在任何时候都有可能被垃圾回收。虚引用的使用必须和引用队列Reference Queue联合使用</p><p><strong>面试官</strong>：对象什么时候可以被垃圾器回收</p><p><strong>候选人:</strong></p><p>思考一会~~</p><p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p><p>如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法</p><p>通常都使用可达性分析算法来确定是不是垃圾</p><p><strong>面试官</strong>： JVM 垃圾回收算法有哪些？</p><p><strong>候选人:</strong></p><p>我记得一共有四种，分别是标记清除算法、复制算法、标记整理算法、分代回收</p><p><strong>面试官</strong>： 你能详细聊一下分代回收吗？</p><p><strong>候选人:</strong></p><p>关于分代回收是这样的</p><p>在java8时，堆被分为了两份：新生代和老年代，它们默认空间占用比例是1:2</p><p>对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区默认空间占用比例是8:1:1</p><p>具体的工作机制是有些情况：</p><p>1）当创建一个对象的时候，那么这个对象会被分配在新生代的Eden区。当Eden区要满了时候，触发YoungGC。</p><p>2）当进行YoungGC后，此时在Eden区存活的对象被移动到S0区，并且<strong>当前对象的年龄会加1</strong>，清空Eden区。</p><p>3）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S0中的对象，移动到S1区中，这些对象的年龄会加1，清空Eden区和S0区。</p><p>4）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S1中的对象，移动到S0区中，这些对象的年龄会加1，清空Eden区和S1区。</p><p>5）对象的年龄达到了某一个限定的值（<strong>默认15岁</strong>  ），那么这个对象就会进入到老年代中。</p><p>当然也有特殊情况，如果进入Eden区的是一个大对象，在触发YoungGC的时候，会直接存放到老年代</p><p>当老年代满了之后，<strong>触发FullGC</strong>。<strong>FullGC同时回收新生代和老年代</strong>，当前只会存在一个FullGC的线程进行执行，其他的线程全部会被挂起。  我们在程序中要尽量避免FullGC的出现。</p><p><strong>面试官</strong>：讲一下新生代、老年代、永久代的区别？</p><p><strong>候选人:</strong></p><p>嗯！是这样的，简单说就是</p><p><strong>新生代</strong>主要用来存放新生的对象。</p><p><strong>老年代</strong>主要存放应用中生命周期长的内存对象。</p><p><strong>永久代</strong>指的是永久保存区域。主要存放Class和Meta（元数据）的信息。在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（<strong>元空间</strong>）的区域。元空间和永久代类似，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。</p><p><strong>面试官</strong>：说一下 JVM 有哪些垃圾回收器？</p><p><strong>候选人:</strong></p><p>在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器（JDK8默认）、CMS（并发）垃圾收集器、G1垃圾收集器（JDK9默认）</p><p><strong>面试官</strong>：Minor GC、Major GC、Full GC是什么</p><p><strong>候选人:</strong></p><p>嗯，其实它们指的是不同代之间的垃圾回收</p><p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p><p>Major GC 老年代区域的垃圾回收，老年代空间不足时，会先尝试触发Minor GC。Minor GC之后空间还不足，则会触发Major GC，Major GC速度比较慢，暂停时间长</p><p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p></blockquote><h3 id="5-4-JVM实践（调优）"><a href="#5-4-JVM实践（调优）" class="headerlink" title="5.4 JVM实践（调优）"></a>5.4 JVM实践（调优）</h3><blockquote><p><strong>面试官</strong>：JVM 调优的参数可以在哪里设置参数值？</p><p><strong>候选人:</strong></p><p>我们当时的项目是springboot项目，可以在项目启动的时候，java -jar中加入参数就行了</p><p><strong>面试官</strong>：用的 JVM 调优的参数都有哪些？</p><p><strong>候选人:</strong></p><p>嗯，这些参数是比较多的</p><p>我记得当时我们设置过堆的大小，像-Xms和-Xmx</p><p>还有就是可以设置年轻代中Eden区和两个Survivor区的大小比例</p><p>还有就是可以设置使用哪种垃圾回收器等等。具体的指令还真记不太清楚。</p><p><strong>面试官</strong>：嗯，好的，你们平时调试 JVM都用了哪些工具呢？</p><p><strong>候选人:</strong></p><p>嗯，我们一般都是使用jdk自带的一些工具，比如</p><p>jps 输出JVM中运行的进程状态信息</p><p>jstack查看java进程内<strong>线程的堆栈</strong>信息。</p><p>jmap 用于生成堆转存快照</p><p>jstat用于JVM统计监测工具</p><p>还有一些可视化工具，像jconsole和VisualVM等</p><p><strong>面试官</strong>：假如项目中产生了java内存泄露，你说一下你的排查思路？</p><p><strong>候选人:</strong></p><p>嗯，这个我在之前项目排查过</p><p>第一呢可以通过jmap指定打印他的内存快照 dump文件，不过有的情况打印不了，我们会设置vm参数让程序自动生成dump文件</p><p>第二，可以通过工具去分析 dump文件，jdk自带的VisualVM就可以分析</p><p>第三，通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</p><p>第四，找到对应的代码，通过阅读上下文的情况，进行修复即可</p><p><strong>面试官</strong>：好的，那现在再来说一种情况，就是说服务器CPU持续飙高，你的排查方案与思路？</p><p><strong>候选人:</strong></p><p>嗯，我思考一下~~</p><p>可以这么做~~</p><p>第一可以使用使用top命令查看占用cpu的情况</p><p>第二通过top命令查看后，可以查看是哪一个进程占用cpu较高，记录这个进程id</p><p>第三可以通过ps 查看当前进程中的线程信息，看看哪个线程的cpu占用较高</p><p>第四可以jstack命令打印进行的id，找到这个线程，就可以进一步定位问题代码的行号</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合面试题</title>
      <link href="/2023/10/18/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/10/18/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Java集合相关面试题"><a href="#Java集合相关面试题" class="headerlink" title="Java集合相关面试题"></a>Java集合相关面试题</h1><h2 id="导学"><a href="#导学" class="headerlink" title="导学"></a>导学</h2><p>这次课程主要涉及到的是List和Map相关的面试题，比较高频就是</p><ul><li><p>ArrayList</p></li><li><p>LinkedList</p></li><li><p>HashMap</p></li><li><p>ConcurrentHashMap</p></li></ul><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211214677.png" alt="image-20230427162524322" style="zoom:50%;" /><ul><li>ArrayList底层实现是数组</li><li>LinkedList底层实现是双向链表</li><li>HashMap的底层实现使用了众多数据结构，包含了数组、链表、散列表、红黑树等</li></ul><p>在讲解这些集合之后，我们会讲解数据结构，知道了数据结构的特点之后，熟悉集合就更加简单了。在讲解数据结构之前，我们也会简单普及一下算法复杂度分析，让大家能够评判代码的好坏，也能更加深入去理解数据结构和集合。</p><h2 id="1-算法复杂度分析"><a href="#1-算法复杂度分析" class="headerlink" title="1 算法复杂度分析"></a>1 算法复杂度分析</h2><h3 id="1-1-为什么要进行复杂度分析？"><a href="#1-1-为什么要进行复杂度分析？" class="headerlink" title="1.1 为什么要进行复杂度分析？"></a>1.1 为什么要进行复杂度分析？</h3><p>我们先来看下面这个代码，你能评判这个代码的好坏吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ** *求**1~n**的累加和</span></span><br><span class="line"><span class="comment"> ** <span class="doctag">@param</span>* *n</span></span><br><span class="line"><span class="comment"> ** <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">     sum = sum + i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实学习算法复杂度的好处就是：</p><ul><li><p>指导你编写出性能更优的代码</p></li><li><p>评判别人写的代码的好坏</p></li></ul><blockquote><p>相信你学完了算法复杂度分析，就有能力评判上面代码的好坏了</p></blockquote><p>关于算法复杂度分析，包含了两个内容，一个是时间复杂度，一个是空间复杂度，通常情况下说复杂度，都是指时间复杂度，我们也会重点讲解时间复杂度</p><h3 id="1-2-时间复杂度"><a href="#1-2-时间复杂度" class="headerlink" title="1.2 时间复杂度"></a>1.2 时间复杂度</h3><h4 id="1-2-1-案例"><a href="#1-2-1-案例" class="headerlink" title="1.2.1 案例"></a>1.2.1 案例</h4><p>时间复杂度分析：简单来说就是评估代码的执行耗时的，大家还是看刚才的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ** *求**1~n**的累加和</span></span><br><span class="line"><span class="comment"> ** <span class="doctag">@param</span>* *n</span></span><br><span class="line"><span class="comment"> ** <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">     sum = sum + i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析这个代码的时间复杂度，分析过程如下：</p><p>1.假如每行代码的执行耗时一样：1ms</p><p>2.分析这段代码总执行多少行？3n+3</p><p>3.代码耗时总时间： T(n) &#x3D; (3n + 3) * 1ms</p><blockquote><p>T(n):就是代码总耗时</p></blockquote><p>我们现在有了总耗时，需要借助大O表示法来计算这个代码的时间复杂度</p><h4 id="1-2-2-大O表示法"><a href="#1-2-2-大O表示法" class="headerlink" title="1.2.2 大O表示法"></a>1.2.2 大O表示法</h4><p><strong>大O表示法</strong>：不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>。</p><p>刚才的代码示例总耗时公式为：T(n) &#x3D; (3n + 3) * 1ms</p><blockquote><p>其中 (3n + 3) 是代码的总行数，每行执行的时间都一样，所以得出结论：</p><p><strong>T(n)与代码的执行次数成正比(代码行数越多，执行时间越长)</strong></p></blockquote><p>不过，大O表示法只需要代码执行时间与数据规模的增长趋势，公式可以简化如下：</p><p>T(n) &#x3D;O(3n + 3)————&gt; T(n) &#x3D; O(n)</p><blockquote><p>当n很大时，公式中的低阶，常量，系数三部分并不左右其增长趋势，因此可以忽略，我们只需要记录一个最大的量级就可以了</p></blockquote><p>下图也能表明数据的趋势</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215484.png" alt="image-20230427173120668"></p><h4 id="1-2-3-常见复杂度表示形式"><a href="#1-2-3-常见复杂度表示形式" class="headerlink" title="1.2.3 常见复杂度表示形式"></a>1.2.3 常见复杂度表示形式</h4><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215351.png" alt="image-20230427173742389"></p><p>速记口诀：<strong>常对幂指阶</strong></p><p>越在上面的性能就越高，越往下性能就越低</p><p>下图是一些比较常见时间复杂度的时间与数据规模的趋势：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215987.png" alt="image-20230427173937663"></p><h4 id="1-2-4-时间复杂度O-1"><a href="#1-2-4-时间复杂度O-1" class="headerlink" title="1.2.4 时间复杂度O(1)"></a>1.2.4 时间复杂度O(1)</h4><p>实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test01</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i+j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码只有三行，它的复杂度也是O(1)，而不是O(3)</p><p>再看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        sum = sum+i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个代码中因为循环次数是固定的就是100次，这样的代码复杂度我们认为也是O(1)</p><p>一句话总结：<strong>只要代码的执行时间不随着n的增大而增大，这样的代码复杂度都是O(1)</strong></p><h4 id="1-2-5-时间复杂度O-n"><a href="#1-2-5-时间复杂度O-n" class="headerlink" title="1.2.5 时间复杂度O(n)"></a>1.2.5 时间复杂度O(n)</h4><p>实例代码1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求1~n的累加和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一层for循序时间复杂度就是O(n)</p><p>实例代码2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum2</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            sum = sum + i * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码的执行行数为：O( 3n^2  + 3n + 3 )，不过，依据大O表示的规则：<strong>常量、系数、低阶，可以忽略</strong></p><p>所以这个代码最终的时间复杂度为：O(n^2)</p><h4 id="1-2-6-时间复杂度O-logn"><a href="#1-2-6-时间复杂度O-logn" class="headerlink" title="1.2.6 时间复杂度O(logn)"></a>1.2.6 时间复杂度O(logn)</h4><p>对数复杂度非常的常见，但相对比较难以分析，实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析这个代码的复杂度，我们必须要再强调一个前提：<strong>复杂度分析就是要弄清楚代码的执行次数和数据规模n之间的关系</strong></p><p>以上代码最关键的一行是：<code>i = i * 2</code>，这行代码可以决定这个while循环执行代码的行数，<code>i</code>的值是可以无限接近<code>n</code>的值的。如果<code>i</code> 一旦大于等于了<code>n</code>则循环条件就不满足了。也就说达到了最大的行数。我们可以分析一下<code>i</code>这个值变化的过程</p><p>分析过程如下：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215988.png" alt="image-20230427174832858"></p><p>由此可知，代码的时间复杂度表示为O(log n)</p><h4 id="1-2-7-时间复杂度O-n-log-n"><a href="#1-2-7-时间复杂度O-n-log-n" class="headerlink" title="1.2.7 时间复杂度O(n * log n)"></a>1.2.7 时间复杂度O(n * log n)</h4><p>分析完O( log n )，那O( n * log n )就很容易理解了，比如下列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">        test04(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-空间复杂度"><a href="#1-3-空间复杂度" class="headerlink" title="1.3 空间复杂度"></a>1.3 空间复杂度</h3><p>空间复杂度全称是渐进空间复杂度，表示算法占用的额外<strong>存储空间</strong>与<strong>数据规模</strong>之间的增长关系</p><p>看下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">        sum = sum+i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行并不需要占用额外的存储空间，只需要常量级的内存空间大小，因此空间复杂度是O(1)</p><p>再来看一个其他例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">        a[i] = i * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        System.out.println(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入一个变量n，决定申请多少的int数组空间内存，此段代码的空间复杂度为O(n)</p><p>我们常见的空间复杂度就是O(1),O(n),O(n ^2)，其他像对数阶的复杂度几乎用不到，因此空间复杂度比时间复杂度分析要简单的多。</p><h2 id="2-List相关面试题"><a href="#2-List相关面试题" class="headerlink" title="2 List相关面试题"></a>2 List相关面试题</h2><h3 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h3><h4 id="2-1-1-数组概述"><a href="#2-1-1-数组概述" class="headerlink" title="2.1.1 数组概述"></a>2.1.1 数组概述</h4><p>数组（Array）是一种用<strong>连续的内存空间</strong>存储<strong>相同数据类型</strong>数据的线性数据结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">22</span>,<span class="number">33</span>,<span class="number">88</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">25</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215989.png" alt="image-20230427175545402"></p><p>我们定义了这么一个数组之后，在内存的表示是这样的：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215990.png" alt="image-20230427175633253"></p><p>现在假如，我们通过<code>arrar[1]</code>，想要获得下标为1这个元素，但是现在栈内存中指向的堆内存数组的首地址，它是如何获取下标为1这个数据的？</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215991.png" alt="image-20230427175849493"></p><h4 id="2-1-2-寻址公式"><a href="#2-1-2-寻址公式" class="headerlink" title="2.1.2 寻址公式"></a>2.1.2 寻址公式</h4><p>为了方便大家理解，我们把数组的内存地址稍微改了一下，都改成了数字，如下图</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215993.png" alt="image-20230427180056509"></p><p>在数组在内存中查找元素的时候，是有一个寻址公式的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[i] = baseAddress + i * dataTypeSize</span><br></pre></td></tr></table></figure><blockquote><p>baseAddress：数组的首地址，目前是10</p><p>dataTypeSize：代表数组中元素类型的大小，目前数组重存储的是int型的数据，dataTypeSize&#x3D;4个字节</p><p>arr：指的是数组</p><p>i：指的是数组的下标</p></blockquote><p>有了寻址公式以后，我们再来获取一下下标为1的元素，这个是原来的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">22</span>,<span class="number">33</span>,<span class="number">88</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">25</span>&#125;;</span><br></pre></td></tr></table></figure><p>套入公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">1</span>] =<span class="number">10</span> + i * <span class="number">4</span> = <span class="number">14</span></span><br></pre></td></tr></table></figure><p>获取到14这个地址，就能获取到下标为1的这个元素了。</p><h4 id="2-1-3-操作数组的时间复杂度"><a href="#2-1-3-操作数组的时间复杂度" class="headerlink" title="2.1.3 操作数组的时间复杂度"></a>2.1.3 操作数组的时间复杂度</h4><p><strong>1.随机查询(根据索引查询)</strong></p><p>数组元素的访问是通过下标来访问的，计算机通过数组的<strong>首地址</strong>和<strong>寻址公式</strong>能够很快速的找到想要访问的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test01</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a[i];</span><br><span class="line">   <span class="comment">// a[i] = baseAddress + i \* dataSize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的执行次数并不会随着数组的数据规模大小变化而变化，是常数级的，所以查询数据操作的时间复杂度是O(1)</p><p><strong>2. 未知索引查询O(n)或O(log2n)</strong></p><p>情况一：查找数组内的元素，查找55号数据，遍历数组时间复杂度为O(n)</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215994.png" alt="image-20221007101831281"></p><p>情况二：查找排序后数组内的元素，通过二分查找算法查找55号数据时间复杂度为O(logn)</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215995.png" alt="image-20221007101811885"></p><p><strong>3.插入O(n)</strong></p><p>数组是一段连续的内存空间，因此为了保证数组的连续性会使得数组的插入和删除的效率变的很低。</p><p>假设数组的长度为 n，现在如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。如下图所示：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215996.png" alt="image-20220820104903422"></p><p>新增之后的数据变化，如下</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215997.png" alt="image-20220820104950846"></p><p>所以：</p><p>插入操作，最好情况下是O(1)的，最坏情况下是O(n)的，**平均情况下的时间复杂度是O(n)**。</p><p><strong>4.删除O(n)</strong></p><p>同理可得：如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了，时间复杂度仍然是O(n)。</p><h3 id="2-2-ArrayList源码分析"><a href="#2-2-ArrayList源码分析" class="headerlink" title="2.2 ArrayList源码分析"></a>2.2 ArrayList源码分析</h3><p>分析ArrayList源码主要从三个方面去翻阅：成员变量，构造函数，关键方法</p><blockquote><p>以下源码都来源于jdk1.8</p></blockquote><h4 id="2-2-1-成员变量"><a href="#2-2-1-成员变量" class="headerlink" title="2.2.1 成员变量"></a>2.2.1 成员变量</h4><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215998.png" alt="image-20230427192118259"></p><blockquote><p><em>DEFAULT_CAPACITY</em> &#x3D; 10;  默认初始的容量**(CAPACITY)</p><p><em>EMPTY_ELEMENTDATA</em> &#x3D; {}; 用于空实例的共享空数组实例</p><p><em>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</em> &#x3D; {};用于默认大小的空实例的共享空数组实例</p><p>Object[] elementData;  存储元素的数组缓冲区</p><p>int size;     ArrayList的大小（它包含的元素数量）</p></blockquote><h4 id="2-2-2-构造方法"><a href="#2-2-2-构造方法" class="headerlink" title="2.2.2 构造方法"></a>2.2.2 构造方法</h4><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215999.png" alt="image-20230427192154014"></p><blockquote><ul><li><p>第一个构造是带初始化容量的构造函数，可以按照指定的容量初始化数组</p></li><li><p>第二个是无参构造函数，默认创建一个空集合</p></li></ul></blockquote><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215000.png" alt="image-20230427192200918"></p><blockquote><p>将collection对象转换成数组，然后将数组的地址的赋给elementData</p></blockquote><h4 id="2-2-3-ArrayList源码分析"><a href="#2-2-3-ArrayList源码分析" class="headerlink" title="2.2.3 ArrayList源码分析"></a>2.2.3 ArrayList源码分析</h4><p>添加数据的流程</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215001.png" alt="image-20230427192644244"></p><p><strong>结论：</strong></p><ul><li>底层数据结构</li></ul><p>ArrayList底层是用动态的数组实现的</p><ul><li>初始容量</li></ul><p>ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10</p><ul><li>扩容逻辑</li></ul><p>ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组</p><ul><li><p>添加逻辑</p><ul><li><p>确保数组已使用长度（size）加1之后足够存下下一个数据 </p></li><li><p>计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</p></li><li><p>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。</p></li><li><p>返回添加成功布尔值。</p></li></ul></li></ul><h4 id="2-2-4-面试题-ArrayList-list-x3D-new-ArrayList-10-中的list扩容几次"><a href="#2-2-4-面试题-ArrayList-list-x3D-new-ArrayList-10-中的list扩容几次" class="headerlink" title="2.2.4 面试题-ArrayList list&#x3D;new ArrayList(10)中的list扩容几次"></a>2.2.4 面试题-ArrayList list&#x3D;new ArrayList(10)中的list扩容几次</h4><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆</p></blockquote><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215002.png" alt="image-20230428185505677"></p><p>参考回答：</p><p> 该语句只是声明和实例了一个 ArrayList，指定了容量为 10，未扩容 </p><h4 id="2-2-4-面试题-如何实现数组和List之间的转换"><a href="#2-2-4-面试题-如何实现数组和List之间的转换" class="headerlink" title="2.2.4 面试题-如何实现数组和List之间的转换"></a>2.2.4 面试题-如何实现数组和List之间的转换</h4><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆</p></blockquote><p>如下代码：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215003.png" alt="image-20230428185600918"></p><p>参考回答：</p><ul><li><p>数组转List ，使用JDK中java.util.Arrays工具类的asList方法</p></li><li><p>List转数组，使用List的toArray方法。无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组</p></li></ul><p>面试官再问：</p><p>1，用Arrays.asList转List后，如果修改了数组内容，list受影响吗</p><p>2，List用toArray转数组后，如果修改了List内容，数组受影响吗</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215004.png" alt="image-20230428185657791"></p><blockquote><p>数组转List受影响</p><p>List转数组不受影响</p></blockquote><p>再答：</p><p>1，用Arrays.asList转List后，如果修改了数组内容，list受影响吗</p><p>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</p><p>2，List用toArray转数组后，如果修改了List内容，数组受影响吗</p><p>list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</p><h3 id="2-3-链表"><a href="#2-3-链表" class="headerlink" title="2.3 链表"></a>2.3 链表</h3><h4 id="2-3-1-单向链表"><a href="#2-3-1-单向链表" class="headerlink" title="2.3.1 单向链表"></a>2.3.1 单向链表</h4><ul><li><p>链表中的每一个元素称之为结点（Node）</p></li><li><p>物理存储单元上，非连续、非顺序的存储结构</p></li><li><p>单向链表：每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。记录下个结点地址的指针叫作后继指针 next</p></li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215005.png" alt="image-20230428185922776"></p><p>代码实现参考：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215006.png" alt="image-20230428185945929"></p><p>链表中的某个节点为B，B的下一个节点为C         表示： B.next&#x3D;&#x3D;C</p><h4 id="2-3-2-单向链表时间复杂度分析"><a href="#2-3-2-单向链表时间复杂度分析" class="headerlink" title="2.3.2 单向链表时间复杂度分析"></a>2.3.2 单向链表时间复杂度分析</h4><p>（1）查询操作</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215007.png" alt="image-20230428190130901"></p><ul><li><p>只有在查询头节点的时候不需要遍历链表，时间复杂度是O(1)</p></li><li><p>查询其他结点需要遍历链表，时间复杂度是O(n)</p></li></ul><p>（2）插入和删除操作</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215008.png" alt="image-20230428190210915"></p><ul><li>只有在添加和删除头节点的时候不需要遍历链表，时间复杂度是O(1)</li><li>添加或删除其他结点需要遍历链表找到对应节点后，才能完成新增或删除节点，时间复杂度是O(n)</li></ul><h4 id="2-3-3-双向链表"><a href="#2-3-3-双向链表" class="headerlink" title="2.3.3 双向链表"></a>2.3.3 双向链表</h4><p>而双向链表，顾名思义，它支持两个方向</p><ul><li><p>每个结点不止有一个后继指针 next 指向后面的结点</p></li><li><p>有一个前驱指针 prev 指向前面的结点</p></li></ul><p>参考代码</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215009.png" alt="image-20230428190324752"></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215010.png" alt="image-20230428190353286"></p><p>对比单链表：</p><ul><li><p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址</p></li><li><p>支持双向遍历，这样也带来了双向链表操作的灵活性</p></li></ul><h4 id="2-3-4-双向链表时间复杂度分析"><a href="#2-3-4-双向链表时间复杂度分析" class="headerlink" title="2.3.4 双向链表时间复杂度分析"></a>2.3.4 双向链表时间复杂度分析</h4><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215011.png" alt="image-20230428190450517"></p><p>（1）查询操作</p><ul><li><p>查询头尾结点的时间复杂度是O(1)</p></li><li><p>平均的查询时间复杂度是O(n)</p></li><li><p>给定节点找前驱节点的时间复杂度为O(1)</p></li></ul><p>（2）增删操作</p><ul><li><p>头尾结点增删的时间复杂度为O(1)</p></li><li><p>其他部分结点增删的时间复杂度是 O(n)</p></li><li><p>给定节点增删的时间复杂度为O(1)</p></li></ul><h4 id="2-3-5-面试题-ArrayList和LinkedList的区别是什么？"><a href="#2-3-5-面试题-ArrayList和LinkedList的区别是什么？" class="headerlink" title="2.3.5 面试题-ArrayList和LinkedList的区别是什么？"></a>2.3.5 面试题-ArrayList和LinkedList的区别是什么？</h4><ul><li><p>底层数据结构</p><ul><li><p>ArrayList 是动态数组的数据结构实现</p></li><li><p>LinkedList 是双向链表的数据结构实现</p></li></ul></li><li><p>操作数据效率</p><ul><li>ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询</li><li>查找（未知索引）： ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)</li><li>新增和删除<ul><li>ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)</li><li>LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)</li></ul></li></ul></li><li><p>内存空间占用</p><ul><li><p>ArrayList底层是数组，内存连续，节省内存</p></li><li><p>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</p></li></ul></li><li><p>线程安全</p><ul><li>ArrayList和LinkedList都不是线程安全的</li><li>如果需要保证线程安全，有两种方案：<ul><li>在方法内使用，局部变量则是线程安全的</li><li>使用线程安全的ArrayList和LinkedList</li></ul></li></ul></li></ul><h2 id="3-HashMap相关面试题"><a href="#3-HashMap相关面试题" class="headerlink" title="3 HashMap相关面试题"></a>3 HashMap相关面试题</h2><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215012.png" alt="image-20230428194715016"></p><h3 id="3-1-二叉树"><a href="#3-1-二叉树" class="headerlink" title="3.1 二叉树"></a>3.1 二叉树</h3><h4 id="3-1-1-二叉树概述"><a href="#3-1-1-二叉树概述" class="headerlink" title="3.1.1 二叉树概述"></a>3.1.1 二叉树概述</h4><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</p><p>二叉树每个节点的左子树和右子树也分别满足二叉树的定义。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215013.png" alt="image-20230428194831426"></p><p>Java中有两个方式实现二叉树：数组存储，链式存储。</p><p>基于链式存储的树的节点可定义如下：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215014.png" alt="image-20230428194904383"></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215015.png" alt="image-20230428194931132"></p><h4 id="3-1-2-二叉搜索树"><a href="#3-1-2-二叉搜索树" class="headerlink" title="3.1.2 二叉搜索树"></a>3.1.2 二叉搜索树</h4><p>在二叉树中，比较常见的二叉树有：</p><ul><li><p>满二叉树</p></li><li><p>完全二叉树</p></li><li><p><strong>二叉搜索树</strong></p></li><li><p><strong>红黑树</strong></p></li></ul><p>我们重点讲解二叉搜索树和红黑树</p><p>（1）二叉搜索树概述</p><p>二叉搜索树(Binary Search Tree,BST)又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型</p><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215016.png" alt="image-20230428195206422"></p><p>（2）二叉搜索树-时间复杂度分析</p><p>实际上由于二叉查找树的形态各异，时间复杂度也不尽相同，我画了几棵树我们来看一下插入，查找，删除的时间复杂度</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215017.png" alt="image-20230428195341917"></p><p>插入，查找，删除的时间复杂度<strong>O(logn)</strong></p><p>极端情况下二叉搜索的时间复杂度</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215018.png" alt="image-20230428195449799"></p><p>对于图中这种情况属于最坏的情况，二叉查找树已经退化成了链表，左右子树极度不平衡，此时查找的时间复杂度肯定是O(n)。</p><h4 id="3-1-3-红黑树"><a href="#3-1-3-红黑树" class="headerlink" title="3.1.3 红黑树"></a>3.1.3 红黑树</h4><p>（1）概述</p><p><strong>红黑树（Red Black Tree）</strong>：也是一种自平衡的二叉搜索树(BST)，之前叫做平衡二叉B树（Symmetric Binary B-Tree）</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215019.png" alt="image-20230428195832724"></p><p>（2）红黑树的特质</p><p>性质1：节点要么是<strong>红色</strong>,要么是<strong>黑色</strong></p><p>性质2：根节点是<strong>黑色</strong></p><p>性质3：叶子节点都是黑色的空节点</p><p>性质4：红黑树中红色节点的子节点都是黑色</p><p>性质5：从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</p><p><strong>在添加或删除节点的时候，如果不符合这些性质会发生旋转，以达到所有的性质，保证红黑树的平衡</strong></p><p>（3）红黑树的复杂度</p><ul><li><p>查找：</p><ul><li>红黑树也是一棵BST（二叉搜索树）树，查找操作的时间复杂度为：O(log n)</li></ul></li><li><p>添加：</p><ul><li>添加先要从根节点开始找到元素添加的位置，时间复杂度O(log n)</li><li>添加完成后涉及到复杂度为O(1)的旋转调整操作</li><li>故整体复杂度为：O(log n)</li></ul></li><li><p>删除：</p><ul><li>首先从根节点开始找到被删除元素的位置，时间复杂度O(log n)</li><li>删除完成后涉及到复杂度为O(1)的旋转调整操作</li><li>故整体复杂度为：O(log n)</li></ul></li></ul><h3 id="3-2-散列表"><a href="#3-2-散列表" class="headerlink" title="3.2 散列表"></a>3.2 散列表</h3><p>在HashMap中的最重要的一个数据结构就是散列表，在散列表中又使用到了红黑树和链表</p><h4 id="3-2-1-散列表（Hash-Table）概述"><a href="#3-2-1-散列表（Hash-Table）概述" class="headerlink" title="3.2.1 散列表（Hash Table）概述"></a>3.2.1 散列表（Hash Table）概述</h4><p>散列表(Hash Table)又名哈希表&#x2F;Hash表，是根据键（Key）直接访问在内存存储位置值（Value）的数据结构，它是由数组演化而来的，利用了数组支持按照下标进行随机访问数据的特性</p><p>举个例子：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215020.png" alt="image-20230428200919454"></p><p>假设有100个人参加马拉松，编号是1-100，如果要编程实现根据选手的编号迅速找到选手信息？</p><p>可以把选手信息存入数组中，选手编号就是数组的下标，数组的元素就是选手的信息。</p><p>当我们查询选手信息的时候，只需要根据选手的编号到数组中查询对应的元素就可以快速找到选手的信息，如下图：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215021.png" alt="image-20230428201000814"></p><p>现在需求升级了：</p><p>假设有100个人参加马拉松，不采用1-100的自然数对选手进行编号，编号有一定的规则比如：2023ZHBJ001，其中2023代表年份，ZH代表中国，BJ代表北京，001代表原来的编号，那此时的编号2023ZHBJ001不能直接作为数组的下标，此时应该如何实现呢？</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215022.png" alt="image-20230428201321607"></p><p>我们目前是把选手的信息存入到数组中，不过选手的编号不能直接作为数组的下标，不过，可以把选手的选号进行转换，转换为数值就可以继续作为数组的下标了？</p><p>转换可以使用散列函数进行转换</p><h4 id="3-2-2-散列函数和散列冲突"><a href="#3-2-2-散列函数和散列冲突" class="headerlink" title="3.2.2 散列函数和散列冲突"></a>3.2.2 散列函数和散列冲突</h4><p>将键(key)映射为数组下标的函数叫做散列函数。可以表示为：hashValue &#x3D; hash(key)</p><p>散列函数的基本要求：</p><ul><li><p>散列函数计算得到的散列值必须是大于等于0的正整数，因为hashValue需要作为数组的下标。</p></li><li><p>如果key1&#x3D;&#x3D;key2，那么经过hash后得到的哈希值也必相同即：hash(key1) &#x3D;&#x3D; hash(key2）</p></li><li><p><strong>如果key1 !&#x3D; key2，那么经过hash后得到的哈希值也必不相同即：hash(key1) !&#x3D; hash(key2)</strong></p></li></ul><p>实际的情况下想找一个散列函数能够做到对于不同的key计算得到的散列值都不同几乎是不可能的，即便像著名的MD5,SHA等哈希算法也无法避免这一情况，这就是散列冲突(或者哈希冲突，哈希碰撞，<strong>就是指多个key映射到同一个数组下标位置</strong>)</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215023.png" alt="image-20230428203219225"></p><h4 id="3-2-3-散列冲突-链表法（拉链）"><a href="#3-2-3-散列冲突-链表法（拉链）" class="headerlink" title="3.2.3 散列冲突-链表法（拉链）"></a>3.2.3 散列冲突-链表法（拉链）</h4><p>在散列表中，数组的每个下标位置我们可以称之为桶（bucket）或者槽（slot），每个桶(槽)会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215024.png" alt="image-20230428203437910"></p><p>简单就是，如果有多个key最终的hash值是一样的，就会存入数组的同一个下标中，下标中挂一个链表存入多个数据</p><h4 id="3-2-4-时间复杂度-散列表"><a href="#3-2-4-时间复杂度-散列表" class="headerlink" title="3.2.4 时间复杂度-散列表"></a>3.2.4 时间复杂度-散列表</h4><p>1，插入操作，通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，插入的时间复杂度是 O(1)</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215025.png" alt="image-20230428203711269"></p><blockquote><p>通过计算就可以找到元素</p></blockquote><p>2，当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除</p><ul><li><p>平均情况下基于链表法解决冲突时查询的时间复杂度是O(1)</p></li><li><p>散列表可能会退化为链表,查询的时间复杂度就从 O(1) 退化为 O(n)</p></li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215026.png" alt="image-20230428203858903"></p><ul><li>将链表法中的链表改造为其他高效的动态数据结构，比如红黑树，查询的时间复杂度是 O(logn)</li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215027.png" alt="image-20230428203924816"></p><p>将链表法中的链表改造红黑树还有一个非常重要的原因，可以防止DDos攻击</p><blockquote><p>DDos 攻击:</p><p>分布式拒绝服务攻击(英文意思是Distributed Denial of Service，简称DDoS）</p><p>指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。由于攻击的发出点是分布在不同地方的，这类攻击称为分布式拒绝服务攻击，其中的攻击者可以有多个</p></blockquote><h3 id="3-3-面试题-说一下HashMap的实现原理？"><a href="#3-3-面试题-说一下HashMap的实现原理？" class="headerlink" title="3.3 面试题-说一下HashMap的实现原理？"></a>3.3 面试题-说一下HashMap的实现原理？</h3><p>HashMap的数据结构： 底层使用hash表数据结构，即数组和链表或红黑树</p><ol><li><p>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标 </p></li><li><p>存储时，如果出现hash值相同的key，此时有两种情况。</p></li></ol><p>  a. 如果key相同，则覆盖原始值；</p><p>  b. 如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中 </p><ol start="3"><li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li></ol><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215028.png" alt="image-20230428204902016"></p><p>面试官追问：HashMap的jdk1.7和jdk1.8有什么区别</p><ul><li><p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p></li><li><p>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8） 时并且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。扩容 resize( ) 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表</p></li></ul><h3 id="3-4-面试题-HashMap的put方法的具体流程"><a href="#3-4-面试题-HashMap的put方法的具体流程" class="headerlink" title="3.4 面试题-HashMap的put方法的具体流程"></a>3.4 面试题-HashMap的put方法的具体流程</h3><h4 id="3-4-1-hashMap常见属性"><a href="#3-4-1-hashMap常见属性" class="headerlink" title="3.4.1 hashMap常见属性"></a>3.4.1 hashMap常见属性</h4><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215029.png" alt="image-20230428210404117"></p><h4 id="3-4-2-源码分析"><a href="#3-4-2-源码分析" class="headerlink" title="3.4.2 源码分析"></a>3.4.2 源码分析</h4><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215030.png" alt="image-20230428210450744"></p><ul><li><p>HashMap是懒惰加载，在创建对象时并没有初始化数组</p></li><li><p>在无参的构造函数中，设置了默认的加载因子是0.75</p></li></ul><p>添加数据流程图</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215031.png" alt="image-20230428210624847"></p><p>具体的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断数组是否未初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果未初始化，调用resize方法 进行初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//通过 &amp; 运算求出该数据（key）的数组下标并判断该下标位置是否有数据</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//如果没有，直接将数据放在该下标位置</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//该数组下标有数据的情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//判断该位置数据的key和新来的数据是否一样</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//如果一样，证明为修改操作，该节点的数据赋值给e,后边会用到</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//判断是不是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//如果是红黑树的话，进行红黑树的操作</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//新数据和当前数组既不相同，也不是红黑树节点，证明是链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//判断next节点，如果为空的话，证明遍历到链表尾部了</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//把新值放入链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//因为新插入了一条数据，所以判断链表长度是不是大于等于8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//如果是，进行转换红黑树操作</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断链表当中有数据相同的值，如果一样，证明为修改操作</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//把下一个节点赋值为当前节点</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断e是否为空（e值为修改操作存放原数据的变量）</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">//不为空的话证明是修改操作，取出老值</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">//一定会执行  onlyIfAbsent传进来的是false</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//将新值赋值当前节点</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//返回老值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计数器，计算当前节点的修改次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//当前数组中的数据数量如果大于扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">//进行扩容操作</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//空方法</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">//添加操作时 返回空值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）</p></li><li><p>根据键值key计算hash值得到数组索引</p></li><li><p>判断table[i]&#x3D;&#x3D;null，条件成立，直接新建节点添加</p></li><li><p>如果table[i]&#x3D;&#x3D;null ,不成立</p><p>4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</p><p>4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</p><p>4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value</p></li><li><p>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。</p></li></ol><h3 id="3-5-面试题-讲一讲HashMap的扩容机制"><a href="#3-5-面试题-讲一讲HashMap的扩容机制" class="headerlink" title="3.5 面试题-讲一讲HashMap的扩容机制"></a>3.5 面试题-讲一讲HashMap的扩容机制</h3><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215032.png" alt="image-20230428210844694"></p><p>扩容的流程：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215033.png" alt="image-20230428211031968"></p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容、初始化数组</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//如果当前数组为null的时候，把oldCap老数组容量设置为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">//老的扩容阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断数组容量是否大于0，大于0说明数组已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断当前数组长度是否大于最大数组长度</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">//如果是，将扩容阈值直接设置为int类型的最大数值并直接返回</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果在最大长度范围内，则需要扩容  OldCap &lt;&lt; 1等价于oldCap*2</span></span><br><span class="line">            <span class="comment">//运算过后判断是不是最大值并且oldCap需要大于16</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold  等价于oldThr*2</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果oldCap&lt;0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在，       如果是首次初始化，它的临界值则为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="comment">//数组未初始化的情况，将阈值和扩容因子都设置为默认值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//初始化容量小于16的时候，扩容阈值是没有赋值的</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//创建阈值</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            <span class="comment">//判断新容量和新阈值是否大于最大容量</span></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//计算出来的阈值赋值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        <span class="comment">//根据上边计算得出的容量 创建新的数组       </span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//扩容操作，判断不为空证明不是初始化数组</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">//判断当前下标为j的数组如果不为空的话赋值个e，进行下一步操作</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//将数组位置置空</span></span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">//判断是否有下个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        <span class="comment">//如果没有，就重新计算在新数组中的下标并放进去</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="comment">//有下个节点的情况，并且判断是否已经树化</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//进行红黑树的操作</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">//有下个节点的情况，并且没有树化（链表形式）</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//比如老数组容量是16，那下标就为0-15</span></span><br><span class="line">                        <span class="comment">//扩容操作*2，容量就变为32，下标为0-31</span></span><br><span class="line">                        <span class="comment">//低位：0-15，高位16-31</span></span><br><span class="line">                        <span class="comment">//定义了四个变量</span></span><br><span class="line">                        <span class="comment">//        低位头          低位尾</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//        高位头   高位尾</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//下个节点</span></span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="comment">//循环遍历</span></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">//取出next节点</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//通过 与操作 计算得出结果为0</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//如果低位尾为null，证明当前数组位置为空，没有任何数据</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//将e值放入低位头</span></span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="comment">//低位尾不为null，证明已经有数据了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将数据放入next节点</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                <span class="comment">//记录低位尾数据</span></span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//通过 与操作 计算得出结果不为0</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                 <span class="comment">//如果高位尾为null，证明当前数组位置为空，没有任何数据</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//将e值放入高位头</span></span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="comment">//高位尾不为null，证明已经有数据了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将数据放入next节点</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                               <span class="comment">//记录高位尾数据</span></span><br><span class="line">                               hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="comment">//如果e不为空，证明没有到链表尾部，继续执行循环</span></span><br><span class="line">                        <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//低位尾如果记录的有数据，是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将下一个元素置空</span></span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将低位头放入新数组的原下标位置</span></span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//高位尾如果记录的有数据，是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将下一个元素置空</span></span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将高位头放入新数组的(原下标+原数组容量)位置</span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//返回新的数组对象</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）</p></li><li><p>每次扩容的时候，都是扩容之前容量的2倍； </p></li><li><p>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中</p><ul><li>没有hash冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</li><li>如果是红黑树，走红黑树的添加</li><li>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</li></ul></li></ul><h3 id="3-6-面试题-hashMap的寻址算法"><a href="#3-6-面试题-hashMap的寻址算法" class="headerlink" title="3.6 面试题-hashMap的寻址算法"></a>3.6 面试题-hashMap的寻址算法</h3><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215034.png" alt="image-20230428212501408"></p><p>在putVal方法中，有一个hash(key)方法，这个方法就是来去计算key的hash值的，看下面的代码</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215035.png" alt="image-20230428212601977"></p><p>首先获取key的hashCode值，然后右移16位 异或运算 原来的hashCode值，主要作用就是使原来的hash值更加均匀，减少hash冲突</p><p>有了hash值之后，就很方便的去计算当前key的在数组中存储的下标，看下面的代码：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215036.png" alt="image-20230428212729580"></p><p>(n-1)&amp;hash : 得到数组中的索引，代替取模，性能更好，数组长度必须是2的n次幂</p><p><strong>关于hash值的其他面试题：为何HashMap的数组长度一定是2的次幂？</strong></p><ol><li><p>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</p></li><li><p>扩容时重新计算索引效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</p></li></ol><h3 id="3-7-面试题-hashmap在1-7情况下的多线程死循环问题"><a href="#3-7-面试题-hashmap在1-7情况下的多线程死循环问题" class="headerlink" title="3.7 面试题-hashmap在1.7情况下的多线程死循环问题"></a>3.7 面试题-hashmap在1.7情况下的多线程死循环问题</h3><p>jdk7的的数据结构是：数组+链表</p><p>在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215037.png" alt="image-20230428213115071"></p><ul><li><p>变量e指向的是需要迁移的对象</p></li><li><p>变量next指向的是下一个需要迁移的对象</p></li><li><p>Jdk1.7中的链表采用的头插法</p></li><li><p>在数据迁移的过程中并没有新的对象产生，只是改变了对象的引用</p></li></ul><p>产生死循环的过程：</p><p>线程1和线程2的变量e和next都引用了这个两个节点</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215038.png" alt="image-20230428213533483"></p><p>线程2扩容后，由于头插法，链表顺序颠倒，但是线程1的临时变量e和next还引用了这两个节点</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215039.png" alt="image-20230428214732877"></p><p>第一次循环</p><p>由于线程2迁移的时候，已经把B的next执行了A</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215040.png" alt="image-20230428214806072"></p><p>第二次循环</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215041.png" alt="image-20230428214908652"></p><p>第三次循环</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215043.png" alt="image-20230428214937231"></p><p>参考回答：</p><p>在jdk1.7的hashmap中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环</p><p>比如说，现在有两个线程</p><p>线程一：读取到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入</p><p>线程二：也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。</p><p>线程一：继续执行的时候就会出现死循环的问题。</p><p>线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，</p><p>所以B-&gt;A-&gt;B,形成循环。</p><p>当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），<strong>尾插法</strong>，就避免了jdk7中死循环的问题。</p><h3 id="3-8-面试题-HashSet与HashMap的区别"><a href="#3-8-面试题-HashSet与HashMap的区别" class="headerlink" title="3.8 面试题-HashSet与HashMap的区别"></a>3.8 面试题-HashSet与HashMap的区别</h3><p>(1)HashSet实现了Set接口, 仅存储对象; HashMap实现了 Map接口, 存储的是键值对.</p><p>(2)HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211215044.png" alt="image-20221007110404375"></p><h3 id="3-9-面试题-HashTable与HashMap的区别"><a href="#3-9-面试题-HashTable与HashMap的区别" class="headerlink" title="3.9 面试题-HashTable与HashMap的区别"></a>3.9 面试题-HashTable与HashMap的区别</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆</p></blockquote><p>主要区别：</p><table><thead><tr><th><strong>区别</strong></th><th><strong>HashTable</strong></th><th><strong>HashMap</strong></th></tr></thead><tbody><tr><td>数据结构</td><td>数组+链表</td><td>数组+链表+红黑树</td></tr><tr><td>是否可以为null</td><td>Key和value都不能为null</td><td>可以为null</td></tr><tr><td>hash算法</td><td>key的hashCode()</td><td>二次hash</td></tr><tr><td>扩容方式</td><td>当前容量翻倍 +1</td><td>当前容量翻倍</td></tr><tr><td>线程安全</td><td>同步(synchronized)的，线程安全</td><td>非线程安全</td></tr></tbody></table><p>在实际开中不建议使用HashTable，在多线程环境下可以使用ConcurrentHashMap类</p><h2 id="3-真实面试还原"><a href="#3-真实面试还原" class="headerlink" title="3 真实面试还原"></a>3 真实面试还原</h2><h3 id="3-1-Java常见的集合类"><a href="#3-1-Java常见的集合类" class="headerlink" title="3.1 Java常见的集合类"></a>3.1 Java常见的集合类</h3><blockquote><p><strong>面试官</strong>：说一说Java提供的常见集合？（画一下集合结构图）</p><p><strong>候选人</strong>：</p><p>嗯~~，好的。</p><p>在java中提供了量大类的集合框架，主要分为两类：</p><p>第一个是Collection  属于单列集合，第二个是Map  属于双列集合</p><ul><li>在Collection中有两个子接口List和Set。在我们平常开发的过程中用的比较多像list接口中的实现类ArrarList和LinkedList。  在Set接口中有实现类HashSet和TreeSet。</li><li>在map接口中有很多的实现类，平时比较常见的是HashMap、TreeMap，还有一个线程安全的map:ConcurrentHashMap</li></ul></blockquote><h3 id="3-2-List"><a href="#3-2-List" class="headerlink" title="3.2 List"></a>3.2 List</h3><blockquote><p><strong>面试官</strong>：ArrayList底层是如何实现的？</p><p><strong>候选人</strong>：</p><p>嗯~，我阅读过arraylist的源码，我主要说一下add方法吧</p><p>第一：确保数组已使用长度（size）加1之后足够存下下一个数据 </p><p>第二：计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</p><p>第三：确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。 </p><p>第四：返回添加成功布尔值。 </p><p><strong>面试官</strong>：ArrayList list&#x3D;new ArrayList(10)中的list扩容几次</p><p><strong>候选人</strong>：</p><p>​是new了一个ArrarList并且给了一个构造参数10，对吧？(问题一定要问清楚再答)</p><p><strong>面试官</strong>：是的</p><p><strong>候选人</strong>：</p><p>​    好的，在ArrayList的源码中提供了一个带参数的构造方法，这个参数就是指定的集合初始长度，所以给了一个10的参数，就是指定了集合的初始长度是10，这里面并没有扩容。</p><hr><p><strong>面试官</strong>：如何实现数组和List之间的转换</p><p><strong>候选人</strong>：</p><p>​嗯，这个在我们平时开发很常见</p><p>​    数组转list，可以使用jdk自动的一个工具类Arrars，里面有一个asList方法可以转换为数组</p><p>​    List 转数组，可以直接调用list中的toArray方法，需要给一个参数，指定数组的类型，需要指定数组的长度。</p><p><strong>面试官</strong>：用Arrays.asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗</p><p><strong>候选人</strong>：</p><p>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</p><p>list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</p><hr><p><strong>面试官</strong>：ArrayList 和 LinkedList 的区别是什么？</p><p><strong>候选人</strong>：</p><p>嗯，它们两个主要是底层使用的数据结构不一样，ArrayList 是动态数组，LinkedList 是双向链表，这也导致了它们很多不同的特点。</p><p>1，从操作数据效率来说</p><p>ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询</p><p>查找（未知索引）： ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)</p><p>新增和删除</p><ul><li>ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)</li><li>LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)</li></ul><p>2，从内存空间占用来说</p><p>ArrayList底层是数组，内存连续，节省内存</p><p>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</p><p>3，从线程安全来说，ArrayList和LinkedList都不是线程安全的</p><p><strong>面试官</strong>：嗯，好的，刚才你说了ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？</p><p><strong>候选人</strong>：</p><p>嗯，是这样的，主要有两种解决方案：</p><p>第一：我们使用这个集合，优先在方法内使用，定义为局部变量，这样的话，就不会出现线程安全问题。</p><p>第二：如果非要在成员变量中使用的话，可以使用线程安全的集合来替代</p><p>ArrayList可以通过Collections 的 synchronizedList 方法将 ArrayList 转换成线程安全的容器后再使用。</p><p>LinkedList 换成ConcurrentLinkedQueue来使用</p></blockquote><h3 id="3-4-HashMap"><a href="#3-4-HashMap" class="headerlink" title="3.4 HashMap"></a>3.4 HashMap</h3><blockquote><p><strong>面试官</strong>：说一下HashMap的实现原理？</p><p><strong>候选人</strong>：</p><p>​嗯。它主要分为了一下几个部分：</p><p>1，底层使用hash表数据结构，即数组+（链表 | 红黑树）</p><p>2，添加数据时，计算key的值确定元素在数组中的下标</p><p>​key相同则替换</p><p>​不同则存入链表或红黑树中</p><p>3，获取数据通过key的hash计算数组下标获取元素</p><p><strong>面试官</strong>：HashMap的jdk1.7和jdk1.8有什么区别</p><p><strong>候选人</strong>：</p><ul><li><p>JDK1.8之前采用的拉链法，数组+链表</p></li><li><p>JDK1.8之后采用数组+链表+红黑树，链表长度大于8且数组长度大于64则会从链表转化为红黑树</p></li></ul><p><strong>面试官</strong>：好的，你能说下HashMap的put方法的具体流程吗？</p><p><strong>候选人</strong>：</p><p>嗯好的。</p><ol><li><p>判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）</p></li><li><p>根据键值key计算hash值得到数组索引</p></li><li><p>判断table[i]&#x3D;&#x3D;null，条件成立，直接新建节点添加</p></li><li><p>如果table[i]&#x3D;&#x3D;null ,不成立</p></li></ol><p>  4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</p><p>  4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</p><p>  4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value</p><ol start="5"><li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。</li></ol><p><strong>面试官</strong>：好的，刚才你多次介绍了hsahmap的扩容，能讲一讲HashMap的扩容机制吗？</p><p><strong>候选人</strong>：</p><p>好的</p><ul><li><p>在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）</p></li><li><p>每次扩容的时候，都是扩容之前容量的2倍； </p></li><li><p>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中</p></li><li><p>没有hash冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</p></li><li><p>如果是红黑树，走红黑树的添加</p></li><li><p>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p></li></ul><p><strong>面试官</strong>：好的，刚才你说的通过hash计算后找到数组的下标，是如何找到的呢，你了解hashMap的寻址算法吗？</p><p><strong>候选人</strong>：</p><p>这个哈希方法首先计算出key的hashCode值，然后通过这个hash值右移16位后的二进制进行按位<strong>异或运算</strong>得到最后的hash值。</p><p>在putValue的方法中，计算数组下标的时候使用hash值与数组长度取模得到存储数据下标的位置，hashmap为了性能更好，并没有直接采用取模的方式，而是使用了数组长度-1 得到一个值，用这个值按位与运算hash值，最终得到数组的位置。</p><p><strong>面试官</strong>：为何HashMap的数组长度一定是2的次幂？</p><p><strong>候选人</strong>：</p><p>嗯，好的。hashmap这么设计主要有两个原因：</p><p>第一：</p><p>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</p><p>第二：</p><p>扩容时重新计算索引效率更高：在进行扩容是会进行判断 hash值按位与运算旧数组长租是否 &#x3D;&#x3D; 0 </p><p>如果等于0，则把元素留在原来位置 ，否则新位置是等于旧位置的下标+旧数组长度</p><p><strong>面试官</strong>：好的，我看你对hashmap了解的挺深入的，你知道hashmap在1.7情况下的多线程死循环问题吗？</p><p><strong>候选人</strong>：</p><p>嗯，知道的。是这样</p><p>jdk7的的数据结构是：数组+链表</p><p>在数组进行扩容的时候，因为链表是<strong>头插法</strong>，在进行数据迁移的过程中，有可能导致死循环</p><p>比如说，现在有两个线程</p><p>线程一：<strong>读取</strong>到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入</p><p>线程二也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。</p><p>当线程一再继续执行的时候就会出现死循环的问题。</p><p>线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，所以B-&gt;A-&gt;B,形成循环。</p><p>当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），<strong>尾插法</strong>，就避免了jdk7中死循环的问题。</p><p><strong>面试官</strong>：好的，hashmap是线程安全的吗？</p><p><strong>候选人</strong>：不是线程安全的</p><p><strong>面试官</strong>：那我们想要使用线程安全的map该怎么做呢？</p><p><strong>候选人</strong>：我们可以采用ConcurrentHashMap进行使用，它是一个线程安全的HashMap</p><p><strong>面试官</strong>：那你能聊一下ConcurrentHashMap的原理吗？</p><p><strong>候选人</strong>：好的，请参考《多线程相关面试题》中的ConcurrentHashMap部分的讲解</p><hr><p><strong>面试官</strong>：HashSet与HashMap的区别？</p><p><strong>候选人</strong>：嗯，是这样。</p><p>HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.</p><p><strong>面试官</strong>：HashTable与HashMap的区别</p><p><strong>候选人</strong>：</p><p>嗯，他们的主要区别是有几个吧</p><p>第一，数据结构不一样，hashtable是数组+链表，hashmap在1.8之后改为了数组+链表+红黑树</p><p>第二，hashtable存储数据的时候都不能为null，而hashmap是可以的</p><p>第三，hash算法不同，hashtable是用本地修饰的hashcode值，而hashmap经常了二次hash</p><p>第四，扩容方式不同，hashtable是当前容量翻倍+1，hashmap是当前容量翻倍</p><p>第五，hashtable是线程安全的，操作数据的时候加了锁synchronized，hashmap不是线程安全的，效率更高一些</p><p>在实际开中不建议使用HashTable，在多线程环境下可以使用ConcurrentHashMap类</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合,ArrayList,LinkedList,HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程面试题</title>
      <link href="/2023/10/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/10/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程相关面试题"><a href="#Java多线程相关面试题" class="headerlink" title="Java多线程相关面试题"></a>Java多线程相关面试题</h1><h2 id="1-线程的基础知识"><a href="#1-线程的基础知识" class="headerlink" title="1.线程的基础知识"></a>1.线程的基础知识</h2><h3 id="1-1-线程和进程的区别？"><a href="#1-1-线程和进程的区别？" class="headerlink" title="1.1 线程和进程的区别？"></a>1.1 线程和进程的区别？</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</p><p><strong>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310201753268.png" alt="image-20221026105350827"></p><p>一个进程之内可以分为一到多个线程。</p><p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</p><p>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。在 windows 中进程是不活动的，只是作为线程的容器</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220697.png" alt="image-20221026105442158"></p><p><strong>二者对比</strong></p><ul><li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li><li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</li></ul><h3 id="1-2-并行和并发有什么区别？"><a href="#1-2-并行和并发有什么区别？" class="headerlink" title="1.2 并行和并发有什么区别？"></a>1.2 并行和并发有什么区别？</h3><blockquote><p>难易程度：☆</p><p>出现频率：☆</p></blockquote><p>单核CPU</p><ul><li><p>单核CPU下线程实际还是串行执行的</p></li><li><p>操作系统中有一个组件叫做任务调度器，将cpu的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于cpu在线程间（时间片很短）的切换非常快，人类感觉是同时运行的 。</p></li><li><p>总结为一句话就是： 微观串行，宏观并行</p></li></ul><p>一般会将这种线程轮流使用CPU的做法称为并发（concurrent）</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220698.png" alt="image-20230503203246348"></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220699.png" alt="image-20221026105607248"></p><p>多核CPU</p><p>每个核（core）都可以调度运行线程，这时候线程可以是并行的。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220700.png" alt="image-20230503203330700"></p><p><strong>并发（concurrent）是同一时间应对（dealing with）多件事情的能力</strong></p><p><strong>并行（parallel）是同一时间动手做（doing）多件事情的能力</strong></p><blockquote><p>举例：</p><ul><li><p>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</p></li><li><p>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）</p></li><li><p>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</p></li></ul></blockquote><h3 id="1-3-创建线程的四种方式"><a href="#1-3-创建线程的四种方式" class="headerlink" title="1.3 创建线程的四种方式"></a>1.3 创建线程的四种方式</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>参考回答：</p><p>共有四种方式可以创建线程，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程</p><p>详细创建方式参考下面代码：</p><p>① <strong>继承Thread类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyThread对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② <strong>实现runnable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyRunnable...run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyRunnable对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Thread对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr) ;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ <strong>实现Callable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyCallable...call...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyCallable对象</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建F</span></span><br><span class="line">        FutureTask&lt;String&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(mc) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Thread对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft) ;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用ft的get方法获取执行结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> ft.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④ <strong>线程池创建线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExecutors</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyRunnable...run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyExecutors</span>()) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-runnable-和-callable-有什么区别"><a href="#1-4-runnable-和-callable-有什么区别" class="headerlink" title="1.4 runnable 和 callable 有什么区别"></a>1.4 runnable 和 callable 有什么区别</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>参考回答：</p><ol><li>Runnable 接口run方法没有返回值；Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li><li>Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</li><li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛</li></ol><h3 id="1-5-线程的-run-和-start-有什么区别？"><a href="#1-5-线程的-run-和-start-有什么区别？" class="headerlink" title="1.5 线程的 run()和 start()有什么区别？"></a>1.5 线程的 run()和 start()有什么区别？</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆</p></blockquote><p>start(): 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。</p><p>run(): 封装了要被线程执行的代码，可以被调用多次。</p><h3 id="1-6-线程包括哪些状态，状态之间是如何变化的"><a href="#1-6-线程包括哪些状态，状态之间是如何变化的" class="headerlink" title="1.6 线程包括哪些状态，状态之间是如何变化的"></a>1.6 线程包括哪些状态，状态之间是如何变化的</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>线程的状态可以参考JDK中的Thread类中的枚举State</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尚未启动的线程的线程状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可运行线程的线程状态。处于可运行状态的线程正在 Java 虚拟机中执行，但它可能正在等待来自 * 操作系统的其他资源，例如处理器。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程阻塞等待监视器锁的线程状态。处于阻塞状态的线程正在等待监视器锁进入同步块/方法或在调          * 用Object.wait后重新进入同步块/方法。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待线程的线程状态。由于调用以下方法之一，线程处于等待状态：</span></span><br><span class="line"><span class="comment">* Object.wait没有超时</span></span><br><span class="line"><span class="comment">         * 没有超时的Thread.join</span></span><br><span class="line"><span class="comment">         * LockSupport.park</span></span><br><span class="line"><span class="comment">         * 处于等待状态的线程正在等待另一个线程执行特定操作。</span></span><br><span class="line"><span class="comment">         * 例如，一个对对象调用Object.wait()的线程正在等待另一个线程对该对象调用Object.notify()* 或Object.notifyAll() 。已调用Thread.join()的线程正在等待指定线程终止。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 具有指定等待时间的等待线程的线程状态。由于以指定的正等待时间调用以下方法之一，线程处于定          * 时等待状态：</span></span><br><span class="line"><span class="comment">* Thread.sleep</span></span><br><span class="line"><span class="comment">* Object.wait超时</span></span><br><span class="line"><span class="comment">* Thread.join超时</span></span><br><span class="line"><span class="comment">* LockSupport.parkNanos</span></span><br><span class="line"><span class="comment">* LockSupport.parkUntil</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 已终止线程的线程状态。线程已完成执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>状态之间是如何变化的</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310201747091.png" alt="image-20230503203629212"></p><p>分别是</p><ul><li>新建<ul><li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li><li>此时未与操作系统底层线程关联</li></ul></li><li>可运行<ul><li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li><li>此时与底层线程关联，由操作系统调度执行</li></ul></li><li>终结<ul><li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li><li>此时会取消与底层线程关联</li></ul></li><li>阻塞<ul><li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li><li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li></ul></li><li>等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li></ul></li><li>有时限等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li></ul></li></ul><h3 id="1-7-新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？"><a href="#1-7-新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？" class="headerlink" title="1.7 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？"></a>1.7 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的<strong>join</strong>()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</p><p>代码举例：</p><p>为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        &#125;) ;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();                          <span class="comment">// 加入线程t1,只有t1线程执行完毕以后，再次执行该线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        &#125;) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t2.join();                              <span class="comment">// 加入线程t2,只有t2线程执行完毕以后，再次执行该线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        &#125;) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-notify-和-notifyAll-有什么区别？"><a href="#1-8-notify-和-notifyAll-有什么区别？" class="headerlink" title="1.8 notify()和 notifyAll()有什么区别？"></a>1.8 notify()和 notifyAll()有什么区别？</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆</p></blockquote><p>notifyAll：唤醒所有wait的线程</p><p>notify：只随机唤醒一个 wait 线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...wating...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...flag is true&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...wating...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...flag is true&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; hold lock&quot;</span>);</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-在-java-中-wait-和-sleep-方法的不同？"><a href="#1-9-在-java-中-wait-和-sleep-方法的不同？" class="headerlink" title="1.9 在 java 中 wait 和 sleep 方法的不同？"></a>1.9 在 java 中 wait 和 sleep 方法的不同？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>参考回答：</p><p>共同点</p><ul><li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li></ul><p>不同点</p><ul><li><p>方法归属不同</p><ul><li>sleep(long) 是 Thread 的静态方法</li><li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li></ul></li><li><p>醒来时机不同</p><ul><li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li><li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li><li>它们都可以被打断唤醒</li></ul></li><li><p>锁特性不同（重点）</p><ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li><li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li><li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul></li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitSleepCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sleeping();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">illegalWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        LOCK.wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">waiting</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">                    LOCK.wait(<span class="number">5000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;interrupted...&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            main.debug(<span class="string">&quot;other...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleeping</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;sleeping...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;interrupted...&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            main.debug(<span class="string">&quot;other...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10-如何停止一个正在运行的线程？"><a href="#1-10-如何停止一个正在运行的线程？" class="headerlink" title="1.10 如何停止一个正在运行的线程？"></a>1.10 如何停止一个正在运行的线程？</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆</p></blockquote><p>参考回答：</p><p>有三种方式可以停止线程</p><ul><li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li><li>使用stop方法强行终止（不推荐，方法已作废）</li><li>使用interrupt方法中断线程</li></ul><p>代码参考如下：</p><p>① <strong>使用退出标志，使线程正常退出</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterrupt1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span> ;     <span class="comment">// 线程执行的退出标记</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyThread对象</span></span><br><span class="line">        <span class="type">MyInterrupt1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterrupt1</span>() ;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠6秒</span></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更改标记为true</span></span><br><span class="line">        t1.flag = <span class="literal">true</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② <strong>使用stop方法强行终止</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterrupt2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span> ;     <span class="comment">// 线程执行的退出标记</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyThread对象</span></span><br><span class="line">        <span class="type">MyInterrupt2</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterrupt2</span>() ;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠2秒</span></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用stop方法</span></span><br><span class="line">        t1.stop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ <strong>使用interrupt方法中断线程</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterrupt3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.打断阻塞的线程</span></span><br><span class="line">        <span class="comment">/*Thread t1 = new Thread(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;t1 正在运行...&quot;);</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                Thread.sleep(5000);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;, &quot;t1&quot;);</span></span><br><span class="line"><span class="comment">        t1.start();</span></span><br><span class="line"><span class="comment">        Thread.sleep(500);</span></span><br><span class="line"><span class="comment">        t1.interrupt();</span></span><br><span class="line"><span class="comment">        System.out.println(t1.isInterrupted());*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.打断正常的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> current.isInterrupted();</span><br><span class="line">                <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;打断状态：&quot;</span>+interrupted);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"><span class="comment">//        t2.interrupt();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-线程中并发锁"><a href="#2-线程中并发锁" class="headerlink" title="2.线程中并发锁"></a>2.线程中并发锁</h2><h3 id="2-1-讲一下synchronized关键字的底层原理？"><a href="#2-1-讲一下synchronized关键字的底层原理？" class="headerlink" title="2.1 讲一下synchronized关键字的底层原理？"></a>2.1 讲一下synchronized关键字的底层原理？</h3><blockquote><p>难易程度：☆☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><h4 id="2-1-1-基本使用"><a href="#2-1-1-基本使用" class="headerlink" title="2.1.1 基本使用"></a>2.1.1 基本使用</h4><p>如下抢票的代码，如果不加锁，就会出现超卖或者一张票卖给多个人</p><p>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">getTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到一张票,剩余:&quot;</span> + ticketNum);</span><br><span class="line">            <span class="comment">// 非原子性操作</span></span><br><span class="line">            ticketNum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TicketDemo</span> <span class="variable">ticketDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                ticketDemo.getTicket();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-Monitor"><a href="#2-1-2-Monitor" class="headerlink" title="2.1.2 Monitor"></a>2.1.2 Monitor</h4><p>Monitor 被翻译为监视器，是由jvm提供，c++语言实现</p><p>在代码中想要体现monitor需要借助javap命令查看clsss的字节码，比如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到这个类的class文件，在class文件目录下执行<code>javap -v SyncTest.class</code>，反编译效果如下：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220701.png" alt="image-20230504165342501"></p><blockquote><ul><li>monitorenter    上锁开始的地方</li><li>monitorexit        解锁的地方</li><li>其中被monitorenter和monitorexit包围住的指令就是上锁的代码</li><li>有两个monitorexit的原因，第二个monitorexit是为了防止锁住的代码抛异常后不能及时释放锁</li></ul></blockquote><p>在使用了synchornized代码块时需要指定一个对象，所以synchornized也被称为对象锁</p><p>monitor主要就是跟这个对象产生关联，如下图</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220702.png" alt="image-20230504165833809"></p><p>Monitor内部具体的存储结构：</p><ul><li><p>Owner：存储当前获取锁的线程的，只能有一个线程可以获取</p></li><li><p>EntryList：关联没有抢到锁的线程，处于Blocked状态的线程</p></li><li><p>WaitSet：关联调用了wait方法的线程，处于Waiting状态的线程</p></li></ul><p>具体的流程：</p><ul><li>代码进入synchorized代码块，先让lock（对象锁）关联的monitor，然后判断Owner是否有线程持有</li><li>如果没有线程持有，则让当前线程持有，表示该线程获取锁成功</li><li>如果有线程持有，则让当前线程进入entryList进行阻塞，如果Owner持有的线程已经释放了锁，在EntryList中的线程去竞争锁的持有权（非公平）</li><li>如果代码块中调用了wait()方法，则会进去WaitSet中进行等待</li></ul><p>参考回答：</p><ul><li><p>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</p></li><li><p>它的底层由monitor实现的，monitor是jvm级别的对象（ C++实现），线程获得锁需要使用对象（锁）关联monitor</p></li><li><p>在monitor内部有三个属性，分别是owner、entrylist、waitset</p></li><li><p>其中owner是关联的获得锁的线程，并且只能关联一个线程；entrylist关联的是处于阻塞状态的线程；waitset关联的是处于Waiting状态的线程</p></li></ul><h3 id="2-2-synchronized关键字的底层原理-进阶"><a href="#2-2-synchronized关键字的底层原理-进阶" class="headerlink" title="2.2 synchronized关键字的底层原理-进阶"></a>2.2 synchronized关键字的底层原理-进阶</h3><p>Monitor实现的锁属于重量级锁，你了解过锁升级吗？</p><ul><li><p>Monitor实现的锁属于重量级锁，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</p></li><li><p>在JDK 1.6引入了两种新型锁机制：偏向锁和轻量级锁，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。</p></li></ul><h4 id="2-2-1-对象的内存结构"><a href="#2-2-1-对象的内存结构" class="headerlink" title="2.2.1 对象的内存结构"></a>2.2.1 对象的内存结构</h4><p>在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220703.png" alt="image-20230504172253826"></p><p>我们需要重点分析MarkWord对象头</p><h4 id="2-2-2-MarkWord"><a href="#2-2-2-MarkWord" class="headerlink" title="2.2.2 MarkWord"></a>2.2.2 MarkWord</h4><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220704.png" alt="image-20230504172541922"></p><blockquote><ul><li><p>hashcode：25位的对象标识Hash码</p></li><li><p>age：对象分代年龄占4位</p></li><li><p>biased_lock：偏向锁标识，占1位 ，0表示没有开始偏向锁，1表示开启了偏向锁</p></li><li><p>thread：持有偏向锁的线程ID，占23位</p></li><li><p>epoch：偏向时间戳，占2位</p></li><li><p>ptr_to_lock_record：轻量级锁状态下，指向栈中锁记录的指针，占30位</p></li><li><p>ptr_to_heavyweight_monitor：重量级锁状态下，指向对象监视器Monitor的指针，占30位</p></li></ul></blockquote><p>我们可以通过lock的标识，来判断是哪一种锁的等级</p><ul><li>后三位是001表示无锁</li><li>后三位是101表示偏向锁</li><li>后两位是00表示轻量级锁</li><li>后两位是10表示重量级锁</li></ul><h4 id="2-2-3-再说Monitor重量级锁"><a href="#2-2-3-再说Monitor重量级锁" class="headerlink" title="2.2.3 再说Monitor重量级锁"></a>2.2.3 再说Monitor重量级锁</h4><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，<strong>该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</strong></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220705.png" alt="image-20230504172957271"></p><p>简单说就是：每个对象的对象头都可以设置monoitor的指针，让对象与monitor产生关联</p><h4 id="2-2-4-轻量级锁"><a href="#2-2-4-轻量级锁" class="headerlink" title="2.2.4 轻量级锁"></a>2.2.4 轻量级锁</h4><p>在很多的情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加锁的流程</strong></p><p>1.在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220706.png" alt="image-20230504173520412"></p><p>2.通过CAS指令将Lock Record的地址存储在对象头的mark word中（数据进行交换），如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220707.png" alt="image-20230504173611219"></p><p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为null，起到了一个重入计数器的作用。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220708.png" alt="image-20230504173922343"></p><p>4.如果CAS修改失败，说明发生了竞争，需要膨胀为重量级锁。</p><p><strong>解锁过程</strong></p><p>1.遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record。</p><p>2.如果Lock Record的Mark Word为null，代表这是一次重入，将obj设置为null后continue。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220709.png" alt="image-20230504173955680"></p><p>3.如果Lock Record的 Mark Word不为null，则利用CAS指令将对象头的mark word恢复成为无锁状态。如果失败则膨胀为重量级锁。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220710.png" alt="image-20230504174045458"></p><h4 id="2-2-5-偏向锁"><a href="#2-2-5-偏向锁" class="headerlink" title="2.2.5 偏向锁"></a>2.2.5 偏向锁</h4><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现</p><p>这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加锁的流程</strong></p><p>1.在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220711.png" alt="image-20230504174525256"></p><p>2.通过CAS指令将Lock Record的<strong>线程id</strong>存储在对象头的mark word中，同时也设置偏向锁的标识为101，如果对象处于无锁状态则修改成功，代表该线程获得了偏向锁。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220712.png" alt="image-20230504174505031"></p><p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为null，起到了一个重入计数器的作用。与轻量级锁不同的时，这里不会再次进行cas操作，只是判断对象头中的线程id是否是自己，因为缺少了cas操作，性能相对轻量级锁更好一些</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220713.png" alt="image-20230504174736226"></p><p>解锁流程参考轻量级锁</p><h4 id="2-2-6-参考回答"><a href="#2-2-6-参考回答" class="headerlink" title="2.2.6 参考回答"></a>2.2.6 参考回答</h4><p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p><table><thead><tr><th></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>重量级锁</td><td>底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</td></tr><tr><td>轻量级锁</td><td>线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</td></tr><tr><td>偏向锁</td><td>一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark  word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</td></tr></tbody></table><p><strong>一旦锁发生了竞争，都会升级为重量级锁</strong></p><h3 id="2-3你谈谈-JMM（Java-内存模型）"><a href="#2-3你谈谈-JMM（Java-内存模型）" class="headerlink" title="2.3你谈谈 JMM（Java 内存模型）"></a>2.3你谈谈 JMM（Java 内存模型）</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>JMM(Java Memory Model)Java内存模型,是java虚拟机规范中所定义的一种内存模型。</p><p>Java内存模型(Java Memory Model)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220714.png" alt="image-20230504181638237"></p><p>特点：</p><ol><li><p>所有的共享变量都存储于主内存(计算机的RAM)这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p></li><li><p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p></li><li><p>线程对变量的所有的操作(读，写)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存完成。</p></li></ol><h3 id="2-4-CAS-你知道吗？"><a href="#2-4-CAS-你知道吗？" class="headerlink" title="2.4 CAS 你知道吗？"></a>2.4 CAS 你知道吗？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆</p></blockquote><h4 id="2-4-1-概述及基本工作流程"><a href="#2-4-1-概述及基本工作流程" class="headerlink" title="2.4.1 概述及基本工作流程"></a>2.4.1 概述及基本工作流程</h4><p>CAS的全称是： Compare And Swap(比较再交换)，它体现的一种乐观锁的思想，在无锁情况下保证线程操作共享数据的原子性。</p><p>在JUC（ java.util.concurrent ）包下实现的很多类都用到了CAS操作</p><ul><li><p>AbstractQueuedSynchronizer（AQS框架）</p></li><li><p>AtomicXXX类</p></li></ul><p>例子：</p><p>我们还是基于刚才学习过的JMM内存模型进行说明</p><ul><li>线程1与线程2都从主内存中获取变量int a &#x3D; 100,同时放到各个线程的工作内存中</li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220715.png" alt="image-20230504181947319"></p><blockquote><p>一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当旧的预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。如果CAS操作失败，通过自旋的方式等待并再次尝试，直到成功</p></blockquote><ul><li>线程1操作：V：int a &#x3D; 100，A：int a &#x3D; 100，B：修改后的值：int a &#x3D; 101 (a++)<ul><li>线程1拿A的值与主内存V的值进行比较，判断是否相等</li><li>如果相等，则把B的值101更新到主内存中</li></ul></li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220716.png" alt="image-20230504182129820"></p><ul><li>线程2操作：V：int a &#x3D; 100，A：int a &#x3D; 100，B：修改后的值：int a &#x3D; 99(a–)<ul><li>线程2拿A的值与主内存V的值进行比较，判断是否相等(目前不相等，因为线程1已更新V的值101)</li><li>不相等，则线程2更新失败</li></ul></li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220718.png" alt="image-20230504181827330"></p><ul><li><p>自旋锁操作</p><ul><li><p>因为没有加锁，所以线程不会陷入阻塞，效率较高</p></li><li><p>如果竞争激烈，重试频繁发生，效率会受影响</p></li></ul></li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220719.png" alt="image-20230504182447552"></p><p>需要不断尝试获取共享内存V中最新的值，然后再在新的值的基础上进行更新操作，如果失败就继续尝试获取新的值，直到更新成功</p><h4 id="2-4-2-CAS-底层实现"><a href="#2-4-2-CAS-底层实现" class="headerlink" title="2.4.2 CAS 底层实现"></a>2.4.2 CAS 底层实现</h4><p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220720.png" alt="image-20230504182737931"></p><p>都是native修饰的方法，由系统提供的接口执行，并非java代码实现，一般的思路也都是自旋锁实现</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220721.png" alt="image-20230504182838426"></p><p>在java中比较常见使用有很多，比如ReentrantLock和Atomic开头的线程安全类，都调用了Unsafe中的方法</p><ul><li>ReentrantLock中的一段CAS代码</li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220722.png" alt="image-20230504182958703"></p><h4 id="2-4-3-乐观锁和悲观锁"><a href="#2-4-3-乐观锁和悲观锁" class="headerlink" title="2.4.3 乐观锁和悲观锁"></a>2.4.3 乐观锁和悲观锁</h4><ul><li><p>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</p></li><li><p>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p></li></ul><h3 id="2-5-请谈谈你对-volatile-的理解"><a href="#2-5-请谈谈你对-volatile-的理解" class="headerlink" title="2.5 请谈谈你对 volatile 的理解"></a>2.5 请谈谈你对 volatile 的理解</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p><h4 id="2-5-1-保证线程间的可见性"><a href="#2-5-1-保证线程间的可见性" class="headerlink" title="2.5.1 保证线程间的可见性"></a>2.5.1 保证线程间的可见性</h4><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。</p><p>一个典型的例子：永不停止的循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可见性例子</span></span><br><span class="line"><span class="comment">// -Xint</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForeverLoop</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;modify stop to true...&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;stopped... c:&quot;</span>+ i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行上述代码的时候，发现foo()方法中的循环是结束不了的，也就说读取不到共享变量的值结束循环。</p><p>主要是因为在JVM虚拟机中有一个JIT（即时编辑器）给代码做了优化。</p><blockquote><p>上述代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">&gt;i++;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>在很短的时间内，这个代码执行的次数太多了，当达到了一个阈值，JIT就会优化此代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">&gt;i++;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>当把代码优化成这样子以后，及时<code>stop</code>变量改变为了<code>false</code>也依然停止不了循环</p></blockquote><p>解决方案：</p><p>第一：</p><p>在程序运行的时候加入vm参数<code>-Xint</code>表示禁用即时编辑器，不推荐，得不偿失（其他程序还要使用）</p><p>第二：</p><p>在修饰<code>stop</code>变量的时候加上<code>volatile</code>,表示当前代码禁用了即时编辑器，问题就可以解决，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-禁止进行指令重排序"><a href="#2-5-2-禁止进行指令重排序" class="headerlink" title="2.5.2 禁止进行指令重排序"></a>2.5.2 禁止进行指令重排序</h4><p>用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220723.png" alt="image-20230505082441116"></p><p>在去获取上面的结果的时候，有可能会出现4种情况</p><p>情况一：先执行actor2获取结果—&gt;0,0(正常)</p><p>情况二：先执行actor1中的第一行代码，然后执行actor2获取结果—&gt;0,1(正常)</p><p>情况三：先执行actor1中所有代码，然后执行actor2获取结果—&gt;1,1(正常)</p><p>情况四：先执行actor1中第二行代码，然后执行actor2获取结果—&gt;1,0(发生了指令重排序，影响结果)</p><p><strong>解决方案</strong></p><p>在变量上添加volatile，禁止指令重排序，则可以解决问题</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220724.png" alt="image-20230505082835588"></p><p>屏障添加的示意图</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220725.png" alt="image-20230505082923729"></p><ul><li>写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下</li><li>读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上</li></ul><p><strong>其他补充</strong></p><p>我们上面的解决方案是把volatile加在了int y这个变量上，我们能不能把它加在int x这个变量上呢？</p><p>下面代码使用volatile修饰了x变量</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220726.png" alt="image-20230505083124159"></p><p>屏障添加的示意图</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220727.png" alt="image-20230505083217904"></p><p>这样显然是不行的，主要是因为下面两个原则：</p><ul><li>写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下</li><li>读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上</li></ul><p>所以，现在我们就可以总结一个volatile使用的小妙招：</p><ul><li>写变量让volatile修饰的变量的在代码最后位置</li><li>读变量让volatile修饰的变量的在代码最开始位置</li></ul><p><strong>总结</strong></p><p>①保证线程间的可见性</p><p>用volatile修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</p><p>②禁止进行指令重排序</p><p>指令重排：用volatile修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p><h3 id="2-6-什么是AQS？"><a href="#2-6-什么是AQS？" class="headerlink" title="2.6 什么是AQS？"></a>2.6 什么是AQS？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><h4 id="2-6-1-概述"><a href="#2-6-1-概述" class="headerlink" title="2.6.1 概述"></a>2.6.1 概述</h4><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，它是构建锁或者其他同步组件的基础框架</p><p>AQS与Synchronized的区别</p><table><thead><tr><th><strong>synchronized</strong></th><th><strong>AQS</strong></th></tr></thead><tbody><tr><td>关键字，c++ 语言实现</td><td>java  语言实现</td></tr><tr><td>悲观锁，自动释放锁</td><td>悲观锁，手动开启和关闭</td></tr><tr><td>锁竞争激烈都是重量级锁，性能差</td><td>锁竞争激烈的情况下，提供了多种解决方案</td></tr></tbody></table><p>AQS常见的实现类</p><ul><li><p>ReentrantLock      阻塞式锁</p></li><li><p>Semaphore        信号量</p></li><li><p>CountDownLatch   倒计时锁</p></li></ul><h4 id="2-6-2-工作机制"><a href="#2-6-2-工作机制" class="headerlink" title="2.6.2 工作机制"></a>2.6.2 工作机制</h4><ul><li>在AQS中维护了一个使用了volatile修饰的state属性来表示资源的状态，0表示无锁，1表示有锁</li><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220728.png" alt="image-20230505083840046"></p><blockquote><ul><li>线程0来了以后，去尝试修改state属性，如果发现state属性是0，就修改state状态为1，表示线程0抢锁成功</li><li>线程1和线程2也会先尝试修改state属性，发现state的值已经是1了，有其他线程持有锁，它们都会到FIFO队列中进行等待，</li><li>FIFO是一个双向队列，head属性表示头结点，tail表示尾结点</li></ul></blockquote><p><strong>如果多个线程共同去抢这个资源是如何保证原子性的呢？</strong></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220729.png" alt="image-20230505084451193"></p><p>在去修改state状态的时候，使用的cas自旋锁来保证原子性，确保只能有一个线程修改成功，修改失败的线程将会进入FIFO队列中等待</p><p><strong>AQS是公平锁吗，还是非公平锁？</strong></p><ul><li><p>新的线程与队列中的线程共同来抢资源，是非公平锁</p></li><li><p>新的线程到队列中等待，只让队列中的head线程获取锁，是公平锁</p></li></ul><blockquote><p>比较典型的AQS实现类ReentrantLock，它默认就是非公平锁，新的线程与队列中的线程共同来抢资源</p></blockquote><h3 id="2-5-ReentrantLock的实现原理"><a href="#2-5-ReentrantLock的实现原理" class="headerlink" title="2.5 ReentrantLock的实现原理"></a>2.5 ReentrantLock的实现原理</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><h4 id="2-5-1-概述"><a href="#2-5-1-概述" class="headerlink" title="2.5.1 概述"></a>2.5.1 概述</h4><p>ReentrantLock翻译过来是可重入锁，相对于synchronized它具备以下特点：</p><ul><li><p>可中断</p></li><li><p>可以设置超时时间</p></li><li><p>可以设置公平锁</p></li><li><p>支持多个条件变量</p></li><li><p>与synchronized一样，都支持重入</p></li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220730.png" alt="image-20230505091736569"></p><h4 id="2-5-2-实现原理"><a href="#2-5-2-实现原理" class="headerlink" title="2.5.2 实现原理"></a>2.5.2 实现原理</h4><p>ReentrantLock主要利用<strong>CAS+AQS</strong>队列来实现。它支持公平锁和非公平锁，两者的实现类似</p><p>构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量。</p><p>查看ReentrantLock源码中的构造方法：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220731.png" alt="image-20230505091827720"></p><p>提供了两个构造方法，不带参数的默认为非公平</p><p>如果使用带参数的构造函数，并且传的值为true，则是公平锁</p><p>其中NonfairSync和FairSync这两个类父类都是Sync</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220732.png" alt="image-20230505092151244"></p><p>而Sync的父类是AQS，所以可以得出ReentrantLock底层主要实现就是基于AQS来实现的</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220733.png" alt="image-20230505091833629"></p><p><strong>工作流程</strong></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220734.png" alt="image-20230505092340431"></p><ul><li>线程来抢锁后使用cas的方式修改state状态，修改状态成功为1，则让exclusiveOwnerThread属性指向当前线程，获取锁成功</li><li>假如修改状态失败，则会进入双向队列中等待，head指向双向队列头部，tail指向双向队列尾部</li><li>当exclusiveOwnerThread为null的时候，则会唤醒在双向队列中等待的线程</li><li>公平锁则体现在按照先后顺序获取锁，非公平体现在不在排队的线程也可以抢锁</li></ul><p><strong>总结</strong></p><ul><li>ReentrantLock表示支持重新进入的锁，调用Iock方法获取了锁之后，再次调用Iock,是不会再阻塞 </li><li>ReentrantLock主要利用<strong>CAS+AQS</strong>队列来实现**(提AQS如何实现的)**</li><li>支持公平锁和非公平锁，在提供的构造器的中无参默认是非公平锁，也可以传参设置为公平锁</li></ul><h3 id="2-6-synchronized和Lock有什么区别"><a href="#2-6-synchronized和Lock有什么区别" class="headerlink" title="2.6 synchronized和Lock有什么区别 ?"></a>2.6 synchronized和Lock有什么区别 ?</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>参考回答</p><ul><li>语法层面<ul><li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li><li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li><li>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</li></ul></li><li>功能层面<ul><li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li><li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</li><li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li></ul></li><li>性能层面<ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li></ul></li></ul><h3 id="2-7-死锁产生的条件是什么？"><a href="#2-7-死锁产生的条件是什么？" class="headerlink" title="2.7 死锁产生的条件是什么？"></a>2.7 死锁产生的条件是什么？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p><strong>死锁</strong>：一个线程需要同时获取多把锁，这时就容易发生死锁</p><blockquote><p>例如：</p><p>t1 线程获得A对象锁，接下来想获取B对象的锁</p><p>t2 线程获得B对象锁，接下来想获取A对象的锁 </p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Deadlock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220735.png" alt="image-20220902171032898"></p><p>此时程序并没有结束，这种现象就是死锁现象…线程t1持有A的锁等待获取B锁，线程t2持有B的锁等待获取A的锁。</p><h3 id="2-8-如何进行死锁诊断？"><a href="#2-8-如何进行死锁诊断？" class="headerlink" title="2.8 如何进行死锁诊断？"></a>2.8 如何进行死锁诊断？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>当程序出现了死锁现象，我们可以使用jdk自带的工具：jps和 jstack</p><p>步骤如下：</p><p>第一：查看运行的线程</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220736.png" alt="image-20220902171426738"></p><p>第二：使用jstack查看线程运行的情况，下图是截图的关键信息</p><p>运行命令：<code>jstack -l 46032</code></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220737.png" alt="image-20220902172229567"></p><p><strong>其他解决工具，可视化工具</strong></p><ul><li>jconsole</li></ul><p>用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具</p><p>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p><ul><li>VisualVM：故障处理工具</li></ul><p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈</p><p>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p><h3 id="2-10-ConcurrentHashMap"><a href="#2-10-ConcurrentHashMap" class="headerlink" title="2.10  ConcurrentHashMap"></a>2.10  ConcurrentHashMap</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>ConcurrentHashMap 是一种线程安全的高效Map集合</p><p>底层数据结构：</p><ul><li><p>JDK1.7底层采用分段的数组+链表实现</p></li><li><p>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。</p></li></ul><h4 id="（1）-JDK1-7中concurrentHashMap"><a href="#（1）-JDK1-7中concurrentHashMap" class="headerlink" title="（1） JDK1.7中concurrentHashMap"></a>（1） JDK1.7中concurrentHashMap</h4><p>数据结构</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220738.png" alt="image-20230505092654811"></p><blockquote><ul><li>提供了一个segment数组，在初始化ConcurrentHashMap 的时候可以指定数组的长度，默认是16，一旦初始化之后中间不可扩容</li><li>在每个segment中都可以挂一个HashEntry数组，数组里面可以存储具体的元素，HashEntry数组是可以扩容的</li><li>在HashEntry存储的数组中存储的元素，如果发生冲突，则可以挂单向链表</li></ul></blockquote><p>存储流程</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220739.png" alt="image-20230505093055382"></p><ul><li>先去计算key的hash值，然后确定segment数组下标</li><li>再通过hash值确定hashEntry数组中的下标存储数据</li><li>在进行操作数据的之前，会先判断当前segment对应下标位置是否有线程进行操作，为了线程安全使用的是ReentrantLock进行加锁，如果获取锁是被会使用cas自旋锁进行尝试</li></ul><h4 id="（2）-JDK1-8中concurrentHashMap"><a href="#（2）-JDK1-8中concurrentHashMap" class="headerlink" title="（2） JDK1.8中concurrentHashMap"></a>（2） JDK1.8中concurrentHashMap</h4><p>在JDK1.8中，放弃了Segment臃肿的设计，数据结构跟HashMap的数据结构是一样的：数组+红黑树+链表</p><p>采用 CAS + Synchronized来保证并发安全进行实现</p><ul><li><p>CAS控制数组节点的添加</p></li><li><p>synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题 , 效率得到提升</p></li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220740.png" alt="image-20230505093507265"></p><p><strong>总结</strong></p><ol><li><p>底层数据结构： </p><p>JDK1.7底层采用分段的数组+链表实现 </p><p>JDK1.8采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树 </p></li><li><p>加锁的方式 </p><p>JDK1.7采用Segment分段锁，底层使用的是ReentrantLock </p><p>JDK1.8采用CAS添加新节点，采用synchronized锁定链表或红黑二叉树的首节点，相对Segment分段锁粒度更细，性能更好</p></li></ol><h3 id="2-11-导致并发程序出现问题的根本原因是什么"><a href="#2-11-导致并发程序出现问题的根本原因是什么" class="headerlink" title="2.11 导致并发程序出现问题的根本原因是什么"></a>2.11 导致并发程序出现问题的根本原因是什么</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>Java并发编程三大特性</p><ul><li><p>原子性</p></li><li><p>可见性</p></li><li><p>有序性</p></li></ul><h4 id="（1）原子性"><a href="#（1）原子性" class="headerlink" title="（1）原子性"></a>（1）原子性</h4><p>一个线程在CPU中操作不可暂停，也不可中断，要不执行完成，要不不执行</p><p>比如，如下代码能保证原子性吗？</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220741.png" alt="image-20230505205200628"></p><p>以上代码会出现超卖或者是一张票卖给同一个人，执行并不是原子性的</p><p>解决方案：</p><p>1.synchronized：同步加锁</p><p>2.JUC里面的lock：加锁</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220742.png" alt="image-20230505210853493"></p><h4 id="（3）内存可见性"><a href="#（3）内存可见性" class="headerlink" title="（3）内存可见性"></a>（3）内存可见性</h4><p>内存可见性：让一个线程对共享变量的修改对另一个线程可见</p><p>比如，以下代码不能保证内存可见性</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220743.png" alt="image-20230505211002252"></p><p>解决方案：</p><ul><li><p>synchronized</p></li><li><p>volatile（推荐）</p></li><li><p>LOCK</p></li></ul><h4 id="（3）有序性"><a href="#（3）有序性" class="headerlink" title="（3）有序性"></a>（3）有序性</h4><p>指令重排：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的</p><p>还是之前的例子，如下代码：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220744.png" alt="image-20230505211209336"></p><p>解决方案：</p><ul><li>volatile</li></ul><h2 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3.线程池"></a>3.线程池</h2><h3 id="3-1-说一下线程池的核心参数（线程池的执行原理知道嘛）"><a href="#3-1-说一下线程池的核心参数（线程池的执行原理知道嘛）" class="headerlink" title="3.1 说一下线程池的核心参数（线程池的执行原理知道嘛）"></a>3.1 说一下线程池的核心参数（线程池的执行原理知道嘛）</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>线程池核心参数主要参考ThreadPoolExecutor这个类的7个参数的构造函数</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220745.png" alt="image-20230505220514872"></p><ul><li><p>corePoolSize 核心线程数目</p></li><li><p>maximumPoolSize 最大线程数目 &#x3D; (核心线程+救急线程的最大数目)</p></li><li><p>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</p></li><li><p>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</p></li><li><p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p></li><li><p>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</p></li><li><p>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</p></li></ul><p><strong>工作流程</strong></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220746.png" alt="image-20230505220701835"></p><blockquote><p>1，任务在提交的时候，首先判断核心线程数是否已满，如果没有满则直接添加到工作线程执行</p><p>2，如果核心线程数满了，则判断阻塞队列是否已满，如果没有满，当前任务存入阻塞队列</p><p>3，如果阻塞队列也满了，则判断线程数是否小于最大线程数，如果满足条件，则使用临时线程执行任务</p><p>如果核心或临时线程执行完成任务后会检查阻塞队列中是否有需要执行的线程，如果有，则使用非核心线程执行任务</p><p>4，如果所有线程都在忙着（核心线程+临时线程），则走拒绝策略</p></blockquote><p>拒绝策略：</p><p>1.AbortPolicy：直接抛出异常，默认策略；</p><p>2.CallerRunsPolicy：用调用者所在的线程来执行任务；</p><p>3.DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</p><p>4.DiscardPolicy：直接丢弃任务；</p><p>参考代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadPoolExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> duration;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>(name, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(String name, <span class="type">long</span> duration)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.duration = duration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LoggerUtils.get(<span class="string">&quot;myThread&quot;</span>).debug(<span class="string">&quot;running...&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">                Thread.sleep(duration);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;MyTask(&quot;</span> + name + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        ArrayBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                queue,</span><br><span class="line">                r -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;myThread&quot;</span> + c.getAndIncrement()),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;1&quot;</span>, <span class="number">3600000</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;2&quot;</span>, <span class="number">3600000</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;3&quot;</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;4&quot;</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;5&quot;</span>,<span class="number">3600000</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;6&quot;</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showState</span><span class="params">(ArrayBlockingQueue&lt;Runnable&gt; queue, ThreadPoolExecutor threadPool)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Object&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Runnable runnable : queue) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Field</span> <span class="variable">callable</span> <span class="operator">=</span> FutureTask.class.getDeclaredField(<span class="string">&quot;callable&quot;</span>);</span><br><span class="line">                callable.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">adapter</span> <span class="operator">=</span> callable.get(runnable);</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.util.concurrent.Executors$RunnableAdapter&quot;</span>);</span><br><span class="line">                <span class="type">Field</span> <span class="variable">task</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">                task.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> task.get(adapter);</span><br><span class="line">                tasks.add(o);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LoggerUtils.main.debug(<span class="string">&quot;pool size: &#123;&#125;, queue: &#123;&#125;&quot;</span>, threadPool.getPoolSize(), tasks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-线程池中有哪些常见的阻塞队列"><a href="#3-2-线程池中有哪些常见的阻塞队列" class="headerlink" title="3.2 线程池中有哪些常见的阻塞队列"></a>3.2 线程池中有哪些常见的阻塞队列</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p><p>比较常见的有4个，用的最多是ArrayBlockingQueue和LinkedBlockingQueue</p><p>1.ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO。</p><p>2.LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO。</p><p>3.DelayedWorkQueue ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的</p><p>4.SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p><p><strong>ArrayBlockingQueue的LinkedBlockingQueue区别</strong></p><table><thead><tr><th><strong>LinkedBlockingQueue</strong></th><th><strong>ArrayBlockingQueue</strong></th></tr></thead><tbody><tr><td>默认无界，支持有界</td><td>强制有界</td></tr><tr><td>底层是链表</td><td>底层是数组</td></tr><tr><td>是懒惰的，创建节点的时候添加数据</td><td>提前初始化 Node  数组</td></tr><tr><td>入队会生成新 Node</td><td>Node需要是提前创建好的</td></tr><tr><td>两把锁（头尾）</td><td>一把锁</td></tr></tbody></table><p>左边是LinkedBlockingQueue加锁的方式，右边是ArrayBlockingQueue加锁的方式</p><ul><li>LinkedBlockingQueue读和写各有一把锁，性能相对较好</li><li>ArrayBlockingQueue只有一把锁，读和写公用，性能相对于LinkedBlockingQueue差一些</li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220747.png" alt="image-20230505221424359"></p><h3 id="3-3-如何确定核心线程数"><a href="#3-3-如何确定核心线程数" class="headerlink" title="3.3 如何确定核心线程数"></a>3.3 如何确定核心线程数</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>在设置核心线程数之前，需要先熟悉一些执行线程池执行任务的类型</p><ul><li>IO密集型任务</li></ul><p>一般来说：文件读写、DB读写、网络请求等</p><p>推荐：核心线程数大小设置为2N+1    （N为计算机的CPU核数）</p><ul><li>CPU密集型任务</li></ul><p>一般来说：计算型代码、Bitmap转换、Gson转换等</p><p>推荐：核心线程数大小设置为N+1    （N为计算机的CPU核数）</p><p>java代码查看CPU核数</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220748.png" alt="image-20230505221837189"></p><p><strong>参考回答：</strong></p><p>① 高并发、任务执行时间短 –&gt;（ CPU核数+1 ），减少线程上下文的切换</p><p>② 并发不高、任务执行时间长</p><ul><li><p>IO密集型的任务 –&gt; (CPU核数 * 2 + 1)</p></li><li><p>计算密集型任务 –&gt; （ CPU核数+1 ）</p></li></ul><p>③ 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）</p><h3 id="3-4-线程池的种类有哪些"><a href="#3-4-线程池的种类有哪些" class="headerlink" title="3.4 线程池的种类有哪些"></a>3.4 线程池的种类有哪些</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>在java.util.concurrent.Executors类中提供了大量创建连接池的静态方法，常见就有四种</p><ol><li><p>创建使用固定线程数的线程池</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220749.png" alt="image-20230505221959259"></p><ul><li><p>核心线程数与最大线程数一样，没有救急线程</p></li><li><p>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</p></li><li><p>适用场景：适用于任务量已知，相对耗时的任务</p></li><li><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FixedThreadDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个固定大小的线程池，核心线程数和最大线程数都是3</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> <span class="title class_">FixedThreadDemo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO)执行</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220750.png" alt="image-20230505222050294"></p><ul><li><p>核心线程数和最大线程数都是1</p></li><li><p>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</p></li><li><p>适用场景：适用于按照顺序执行的任务</p></li><li><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewSingleThreadCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//单个线程池，核心线程数和最大线程数都是1</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Demo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可缓存线程池</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220751.png" alt="image-20230505222126391"></p><ul><li><p>核心线程数为0</p></li><li><p>最大线程数是Integer.MAX_VALUE</p></li><li><p>阻塞队列为SynchronousQueue:不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p></li><li><p>适用场景：适合任务数比较密集，但每个任务执行时间较短的情况</p></li><li><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//修改睡眠时间，模拟线程执行需要花费的时间</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(name + <span class="string">&quot;执行完了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个缓存的线程，没有核心线程数，最大线程数为Integer.MAX_VALUE</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Demo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>提供了“延迟”和“周期执行”功能的ThreadPoolExecutor。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220752.png" alt="image-20230505222203615"></p><ul><li><p>适用场景：有定时和延迟执行的任务</p></li><li><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">                System.out.println(name + <span class="string">&quot;, 开始：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;, 结束：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//按照周期执行的线程池，核心线程数为2，最大线程数为Integer.MAX_VALUE</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * schedule 提交任务到线程池中</span></span><br><span class="line"><span class="comment">         * 第一个参数：提交的任务</span></span><br><span class="line"><span class="comment">         * 第二个参数：任务执行的延迟时间</span></span><br><span class="line"><span class="comment">         * 第三个参数：时间单位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">0</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        scheduledThreadPool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="3-5-为什么不建议用Executors创建线程池"><a href="#3-5-为什么不建议用Executors创建线程池" class="headerlink" title="3.5 为什么不建议用Executors创建线程池"></a>3.5 为什么不建议用Executors创建线程池</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>参考阿里开发手册《Java开发手册-嵩山版》</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220753.png" alt="image-20220821003816845"></p><h2 id="4-线程使用场景问题"><a href="#4-线程使用场景问题" class="headerlink" title="4.线程使用场景问题"></a>4.线程使用场景问题</h2><h3 id="4-1-线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）"><a href="#4-1-线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）" class="headerlink" title="4.1 线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）"></a>4.1 线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><h4 id="4-1-1-CountDownLatch"><a href="#4-1-1-CountDownLatch" class="headerlink" title="4.1.1 CountDownLatch"></a>4.1.1 CountDownLatch</h4><p>CountDownLatch（闭锁&#x2F;倒计时锁）用来进行线程同步协作，等待所有线程完成倒计时（一个或者多个线程，等待其他多个线程完成某件事情之后才能执行）</p><ul><li><p>其中构造参数用来初始化等待计数值</p></li><li><p>await() 用来等待计数归零</p></li><li><p>countDown() 用来让计数减一</p></li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220754.png" alt="image-20230505223014946"></p><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//初始化了一个倒计时锁 参数为 3</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-begin...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//count--</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-end...&quot;</span> +latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-begin...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//count--</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-end...&quot;</span> +latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-begin...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//count--</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-end...&quot;</span> +latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-waiting...&quot;</span>);</span><br><span class="line">        <span class="comment">//等待其他线程完成</span></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-wait end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-案例一（es数据批量导入）"><a href="#4-1-2-案例一（es数据批量导入）" class="headerlink" title="4.1.2 案例一（es数据批量导入）"></a>4.1.2 案例一（es数据批量导入）</h4><p>在我们项目上线之前，我们需要把数据库中的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），当时我就想到可以使用线程池的方式导入，利用CountDownLatch来控制，就能避免一次性加载过多，防止内存溢出</p><p>整体流程就是通过CountDownLatch+线程池配合去执行</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220755.png" alt="image-20230505223219951"></p><p>详细实现流程：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220756.png" alt="image-20230505223246059"></p><blockquote><p>详细实现代码，请查看当天代码</p></blockquote><h4 id="4-1-3-案例二（数据汇总）"><a href="#4-1-3-案例二（数据汇总）" class="headerlink" title="4.1.3 案例二（数据汇总）"></a>4.1.3 案例二（数据汇总）</h4><p>在一个电商网站中，用户下单之后，需要查询数据，数据包含了三部分：订单信息、包含的商品、物流信息；这三块信息都在不同的微服务中进行实现的，我们如何完成这个业务呢？</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220757.png" alt="image-20230505223442924"></p><blockquote><p>详细实现代码，请查看当天代码</p></blockquote><ul><li><p>在实际开发的过程中，难免需要调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依赖关系，就可以使用线程池+future来提升性能</p></li><li><p>报表汇总</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220758.png" alt="image-20230505223536657"></p></li></ul><h4 id="4-1-4-案例二（异步调用）"><a href="#4-1-4-案例二（异步调用）" class="headerlink" title="4.1.4 案例二（异步调用）"></a>4.1.4 案例二（异步调用）</h4><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220759.png" alt="image-20230505223640038"></p><p>在进行搜索的时候，需要保存用户的搜索记录，而搜索记录不能影响用户的正常搜索，我们通常会开启一个线程去执行历史记录的保存，在新开启的线程在执行的过程中，可以利用线程提交任务</p><h3 id="4-1-如何控制某个方法允许并发访问线程的数量？"><a href="#4-1-如何控制某个方法允许并发访问线程的数量？" class="headerlink" title="4.1 如何控制某个方法允许并发访问线程的数量？"></a>4.1 如何控制某个方法允许并发访问线程的数量？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆</p></blockquote><p>Semaphore [ˈsɛməˌfɔr] 信号量，是JUC包下的一个工具类，我们可以通过其限制执行的线程数量，达到限流的效果</p><p>当一个线程执行时先通过其方法进行获取许可操作，获取到许可的线程继续执行业务逻辑，当线程执行完成后进行释放许可操作，未获取达到许可的线程进行等待或者直接结束。</p><p>Semaphore两个重要的方法</p><p>lsemaphore.acquire()： 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）</p><p>lsemaphore.release()：释放一个信号量，此时信号量个数+1</p><p>线程任务类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreCase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 semaphore 对象</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 3. 获取许可</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 4. 释放许可</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h2><h3 id="5-1-谈谈你对ThreadLocal的理解"><a href="#5-1-谈谈你对ThreadLocal的理解" class="headerlink" title="5.1 谈谈你对ThreadLocal的理解"></a>5.1 谈谈你对ThreadLocal的理解</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><h4 id="5-1-1-概述"><a href="#5-1-1-概述" class="headerlink" title="5.1.1 概述"></a>5.1.1 概述</h4><p>ThreadLocal是多线程中对于解决线程安全的一个操作类，它会为每个线程都分配一个独立的线程副本从而解决了变量并发访问冲突的问题。ThreadLocal 同时实现了线程内的资源共享</p><p>案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的 Connection 上进行数据库的操作，避免A线程关闭了B线程的连接。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220760.png" alt="image-20230505224057228"></p><h4 id="5-1-2-ThreadLocal基本使用"><a href="#5-1-2-ThreadLocal基本使用" class="headerlink" title="5.1.2 ThreadLocal基本使用"></a>5.1.2 ThreadLocal基本使用</h4><p>三个主要方法：</p><ul><li><p>set(value) 设置值</p></li><li><p>get() 获取值</p></li><li><p>remove() 清除值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            threadLocal.set(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">            print(name);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;-after remove : &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            threadLocal.set(<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">            print(name);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;-after remove : &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">        System.out.println(str + <span class="string">&quot; :&quot;</span> + threadLocal.get());</span><br><span class="line">        <span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-3-ThreadLocal的实现原理-amp-源码解析"><a href="#5-1-3-ThreadLocal的实现原理-amp-源码解析" class="headerlink" title="5.1.3 ThreadLocal的实现原理&amp;源码解析"></a>5.1.3 ThreadLocal的实现原理&amp;源码解析</h4><p>ThreadLocal本质来说就是一个线程内部存储类，从而让多个线程只操作自己内部的值，从而实现线程数据隔离</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220761.png" alt="image-20230505224341410"></p><p>在ThreadLocal中有一个内部类叫做ThreadLocalMap，类似于HashMap</p><p>ThreadLocalMap中有一个属性table数组，这个是真正存储数据的位置</p><p><strong>set方法</strong></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220762.png" alt="image-20230505224626253"></p><p><strong>get方法&#x2F;remove方法</strong></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220763.png" alt="image-20230505224715087"></p><h4 id="5-1-4-ThreadLocal-内存泄露问题"><a href="#5-1-4-ThreadLocal-内存泄露问题" class="headerlink" title="5.1.4 ThreadLocal-内存泄露问题"></a>5.1.4 ThreadLocal-内存泄露问题</h4><p>Java对象中的四种引用类型：强引用、软引用、弱引用、虚引用</p><ul><li>强引用：最为普通的引用方式，表示一个对象处于有用且必须的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收</li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220764.png" alt="image-20230505224755797"></p><ul><li>弱引用：表示一个对象处于可能有用且非必须的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收</li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220765.png" alt="image-20230505224812015"></p><p>每一个Thread维护一个ThreadLocalMap，在ThreadLocalMap中的Entry对象继承了WeakReference。其中key为使用弱引用的ThreadLocal实例，value为线程变量的副本</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211220766.png" alt="image-20230505224857538"></p><p>在使用ThreadLocal的时候，强烈建议：<strong>务必手动remove</strong></p><h2 id="6-真实面试还原"><a href="#6-真实面试还原" class="headerlink" title="6 真实面试还原"></a>6 真实面试还原</h2><h3 id="6-1-线程的基础知识"><a href="#6-1-线程的基础知识" class="headerlink" title="6.1 线程的基础知识"></a>6.1 线程的基础知识</h3><blockquote><p><strong>面试官</strong>：聊一下并行和并发有什么区别？</p><p><strong>候选人：</strong></p><p>是这样的~~</p><p>现在都是多核CPU，在多核CPU下</p><p>并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU</p><p>并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程</p><hr><p><strong>面试官</strong>：说一下线程和进程的区别？</p><p><strong>候选人：</strong></p><p>嗯，好~</p><ul><li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li><li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</li></ul><hr><p><strong>面试官</strong>：如果在java中创建线程有哪些方式？</p><p><strong>候选人：</strong></p><p>在java中一共有四种常见的创建方式，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程。通常情况下，我们项目中都会采用线程池的方式创建线程。</p><p><strong>面试官</strong>：好的，刚才你说的runnable 和 callable 两个接口创建线程有什么不同呢？</p><p><strong>候选人：</strong></p><p>是这样的~</p><p>最主要的两个线程一个是有返回值，一个是没有返回值的。</p><p>Runnable 接口run方法无返回值；Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</p><p>还有一个就是，他们异常处理也不一样。Runnable接口run方法只能抛出运行时异常，也无法捕获处理；Callable接口call方法允许抛出异常，可以获取异常信息</p><p>在实际开发中，如果需要拿到执行的结果，需要使用Callalbe接口创建线程，调用FutureTask.get()得到可以得到返回值，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p><hr><p><strong>面试官</strong>：线程包括哪些状态，状态之间是如何变化的？</p><p><strong>候选人：</strong></p><p>在JDK中的Thread类中的枚举State里面定义了6中线程的状态分别是：新建、可运行、终结、阻塞、等待和有时限等待六种。</p><p>关于线程的状态切换情况比较多。我分别介绍一下</p><p>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态，调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong>状态。如果线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong>状态。当然这些是一个线程正常执行情况。</p><p>如果线程获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，只有当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</p><p>如果线程获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁<strong>等待</strong>状态，当其它持锁线程调用 notify() 或 notifyAll() 方法，会恢复为<strong>可运行</strong>状态</p><p>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</p><p><strong>面试官</strong>：嗯，好的，刚才你说的线程中的 wait 和 sleep方法有什么不同呢？</p><p><strong>候选人：</strong></p><p>它们两个的相同点是都可以让当前线程暂时放弃 CPU 的使用权，进入阻塞状态。</p><p>不同点主要有三个方面：</p><p>第一：方法归属不同</p><p>sleep(long) 是 Thread 的静态方法。而 wait()，是 Object 的成员方法，每个对象都有</p><p>第二：线程醒来时机不同</p><p>线程执行 sleep(long) 会在等待相应毫秒后醒来，而 wait() 需要被 notify 唤醒，wait() 如果不唤醒就一直等下去</p><p>第三：锁特性不同</p><p>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</p><p>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（相当于我放弃 cpu，但你们还可以用）</p><p>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（相当于我放弃 cpu，你们也用不了）</p><p><strong>面试官</strong>：好的，我现在举一个场景，你来分析一下怎么做，新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</p><p><strong>候选人：</strong></p><p>嗯~~，我思考一下 （适当的思考或想一下属于正常情况，脱口而出反而太假[背诵痕迹]）</p><p>可以这么做，在多线程中有多种方法让线程按特定顺序执行，可以用线程类的<strong>join</strong>()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</p><p>比如说：</p><p>使用join方法，T3调用T2，T2调用T1，这样就能确保T1就会先完成而T3最后完成</p><p><strong>面试官</strong>：在我们使用线程的过程中，有两个方法。线程的 run()和 start()有什么区别？</p><p><strong>候选人：</strong></p><p>start方法用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。run方法封装了要被线程执行的代码，可以被调用多次。</p><p><strong>面试官</strong>：那如何停止一个正在运行的线程呢？</p><p><strong>候选人</strong>：</p><p>有三种方式可以停止线程</p><p>第一：可以使用退出标志，使线程正常退出，也就是当run方法完成后线程终止，一般我们加一个标记</p><p>第二：可以使用线程的stop方法强行终止，不过一般不推荐，这个方法已作废</p><p>第三：可以使用线程的interrupt方法中断线程，内部其实也是使用中断标志来中断线程</p><p>我们项目中使用的话，建议使用第一种或第三种方式中断线程</p></blockquote><h3 id="6-2-线程中并发锁"><a href="#6-2-线程中并发锁" class="headerlink" title="6.2 线程中并发锁"></a>6.2 线程中并发锁</h3><blockquote><p><strong>面试官</strong>：讲一下synchronized关键字的底层原理？</p><p><strong>候选人</strong>：</p><p>嗯~~好的，</p><p>synchronized 底层使用的JVM级别中的Monitor 来决定当前线程是否获得了锁，如果某一个线程获得了锁，在没有释放锁之前，其他线程是不能或得到锁的。synchronized 属于悲观锁。</p><p>synchronized 因为需要依赖于JVM级别的Monitor ，相对性能也比较低。</p><p><strong>面试官</strong>：好的，你能具体说下Monitor 吗？</p><p><strong>候选人</strong>：</p><p>monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因</p><p>monitor内部维护了三个变量</p><ul><li><p>WaitSet：保存处于Waiting状态的线程</p></li><li><p>EntryList：保存处于Blocked状态的线程</p></li><li><p>Owner：持有锁的线程</p></li></ul><p>只有一个线程获取到的标志就是在monitor中设置成功了Owner，一个monitor中只能有一个Owner</p><p>在上锁的过程中，如果有其他线程也来抢锁，则进入EntryList 进行阻塞，当获得锁的线程执行完了，释放了锁，就会唤醒EntryList 中等待的线程竞争锁，竞争的时候是非公平的。</p><p><strong>面试官</strong>：好的，那关于synchronized 的锁升级的情况了解吗？</p><p><strong>候选人</strong>：</p><p>嗯，知道一些（要谦虚）</p><p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p><p>重量级锁：底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</p><p>轻量级锁：线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</p><p>偏向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</p><p>一旦锁发生了竞争，都会升级为重量级锁</p><p><strong>面试官</strong>：好的，刚才你说了synchronized它在高并发量的情况下，性能不高，在项目该如何控制使用锁呢？</p><p><strong>候选人</strong>：</p><p>嗯，其实，在高并发下，我们可以采用ReentrantLock来加锁。</p><p><strong>面试官</strong>：嗯，那你说下ReentrantLock的使用方式和底层原理？</p><p><strong>候选人</strong>：</p><p>好的，</p><p>ReentrantLock是一个可重入锁:，调用 lock 方 法获取了锁之后，再次调用 lock，是不会再阻塞，内部直接增加重入次数 就行了，标识这个线程已经重复获取一把锁而不需要等待锁的释放。</p><p>ReentrantLock是属于juc报下的类，属于api层面的锁，跟synchronized一样，都是悲观锁。通过lock()用来获取锁，unlock()释放锁。</p><p>它的底层实现原理主要利用<strong>CAS+AQS队列</strong>来实现。它支持公平锁和非公平锁，两者的实现类似</p><p>构造方法接受一个可选的公平参数（<strong>默认非公平锁</strong>），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高。</p><p><strong>面试官</strong>：好的，刚才你说了CAS和AQS，你能介绍一下吗？</p><p><strong>候选人</strong>：</p><p>好的。</p><p>CAS的全称是： Compare And Swap(比较再交换);它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。</p><ul><li><p>CAS使用到的地方很多：AQS框架、AtomicXXX类</p></li><li><p>在操作共享变量的时候使用的自旋锁，效率上更高一些</p></li><li><p>CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现</p></li></ul><p>AQS的话，其实就一个jdk提供的类AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。</p><p>内部有一个属性 state 属性来表示资源的状态，默认state等于0，表示没有获取锁，state等于1的时候才标明获取到了锁。通过cas 机制设置 state 状态</p><p>在它的内部还提供了基于 FIFO 的等待队列，是一个双向列表，其中</p><ul><li><p>tail 指向队列最后一个元素</p></li><li><p>head  指向队列中最久的一个元素</p></li></ul><p>其中我们刚刚聊的ReentrantLock底层的实现就是一个AQS。</p><p><strong>面试官</strong>：synchronized和Lock有什么区别 ? </p><p><strong>候选人</strong>：</p><p>嗯~~，好的，主要有三个方面不太一样</p><p>第一，语法层面</p><ul><li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现，退出同步代码块锁会自动释放</li><li>Lock 是接口，源码由 jdk 提供，用 java 语言实现，需要手动调用 unlock 方法释放锁</li></ul><p>第二，功能层面</p><ul><li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li><li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量，同时Lock 可以实现不同的场景，如 ReentrantLock， ReentrantReadWriteLock</li></ul><p>第三，性能层面</p><ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li></ul><p>统合来看，需要根据不同的场景来选择不同的锁的使用。</p><hr><p><strong>面试官</strong>：死锁产生的条件是什么？</p><p><strong>候选人</strong>：</p><p>嗯，是这样的，一个线程需要同时获取多把锁，这时就容易发生死锁，举个例子来说：</p><p>t1 线程获得A对象锁，接下来想获取B对象的锁</p><p>t2 线程获得B对象锁，接下来想获取A对象的锁 </p><p>这个时候t1线程和t2线程都在互相等待对方的锁，就产生了死锁</p><p><strong>面试官</strong>：那如果产出了这样的，如何进行死锁诊断？</p><p><strong>候选人</strong>：</p><p>这个也很容易，我们只需要通过jdk自动的工具就能搞定</p><p>我们可以先通过jps来查看当前java程序运行的进程id</p><p>然后通过jstack来查看这个进程id，就能展示出来死锁的问题，并且，可以定位代码的具体行号范围，我们再去找到对应的代码进行排查就行了。</p><hr><p><strong>面试官</strong>：请谈谈你对 volatile 的理解</p><p><strong>候选人</strong>：</p><p>嗯~~</p><p>volatile 是一个关键字，可以修饰类的成员变量、类的静态成员变量，主要有两个功能</p><p>第一：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。</p><p>第二： 禁止进行指令重排序，可以保证代码执行有序性。底层实现原理是，添加了一个<strong>内存屏障</strong>，通过插入内存屏障禁止在内存屏障<strong>前后</strong>的指令执行重排序优化</p><hr><p><strong>本文作者</strong>：接《集合相关面试题》</p><p><strong>面试官</strong>：那你能聊一下ConcurrentHashMap的原理吗？</p><p><strong>候选人</strong>：</p><p>嗯好的，</p><p>ConcurrentHashMap 是一种线程安全的高效Map集合，jdk1.7和1.8也做了很多调整。</p><ul><li>JDK1.7的底层采用是<strong>分段的数组</strong>+<strong>链表</strong> 实现</li><li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。</li></ul><p>在jdk1.7中 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一 种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构 的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修 改时，必须首先获得对应的 Segment的锁。</p><p>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元 素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁</p><p>在jdk1.8中的ConcurrentHashMap 做了较大的优化，性能提升了不少。首先是它的数据结构与jdk1.8的hashMap数据结构完全一致。其次是放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保 证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲 突，就不会产生并发 , 效率得到提升</p></blockquote><h3 id="6-3-线程池"><a href="#6-3-线程池" class="headerlink" title="6.3 线程池"></a>6.3 线程池</h3><blockquote><p><strong>面试官</strong>：线程池的种类有哪些？</p><p><strong>候选人</strong>：</p><p>嗯！是这样</p><p>在jdk中默认提供了4中方式创建线程池</p><p>第一个是：newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回 收空闲线程，若无可回收，则新建线程。 </p><p>第二个是：newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列 中等待。 </p><p>第三个是：newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 </p><p>第四个是：newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><p><strong>面试官</strong>：线程池的核心参数有哪些？</p><p><strong>候选人</strong>：</p><p>在线程池中一共有7个核心参数：</p><ol><li><p>corePoolSize 核心线程数目 - 池中会保留的最多线程数</p></li><li><p>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</p></li><li><p>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</p></li><li><p>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</p></li><li><p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p></li><li><p>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</p></li><li><p>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</p></li></ol><p>  在拒绝策略中又有4中拒绝策略</p><p>  当线程数过多以后，第一种是抛异常、第二种是由调用者执行任务、第三是丢弃当前的任务，第四是丢弃最早排队任务。默认是直接抛异常。</p><p><strong>面试官</strong>：如何确定核心线程池呢？</p><p><strong>候选人</strong>：</p><p>是这样的，我们公司当时有一些规范，为了减少线程上下文的切换，要根据当时部署的服务器的CPU核数来决定，我们规则是：CPU核数+1就是最终的核心线程数。</p><p><strong>面试官</strong>：线程池的执行原理知道吗？</p><p><strong>候选人</strong>：</p><p>嗯~，它是这样的</p><p>首先判断线程池里的核心线程是否都在执行任务，如果不是则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队 列里。如果工作队列满了，则判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任 务。如果已经满了，则交给拒绝策略来处理这个任务。</p><p><strong>面试官</strong>：为什么不建议使用Executors创建线程池呢？</p><p><strong>候选人</strong>：</p><p>好的，其实这个事情在阿里提供的最新开发手册《Java开发手册-嵩山版》中也提到了</p><p>主要原因是如果使用Executors创建线程池的话，它允许的请求队列默认长度是Integer.MAX_VALUE，这样的话，有可能导致堆积大量的请求，从而导致OOM（内存溢出）。</p><p>所以，我们一般推荐使用ThreadPoolExecutor来创建线程池，这样可以明确规定线程池的参数，避免资源的耗尽。</p></blockquote><h3 id="6-4-线程使用场景问题"><a href="#6-4-线程使用场景问题" class="headerlink" title="6.4 线程使用场景问题"></a>6.4 线程使用场景问题</h3><blockquote><p><strong>面试官</strong>：如果控制某一个方法允许并发访问线程的数量？</p><p><strong>候选人</strong>：</p><p>嗯~~，我想一下</p><p>在jdk中提供了一个Semaphore[seməfɔːr]类（信号量）</p><p>它提供了两个方法，semaphore.acquire() 请求信号量，可以限制线程的个数，是一个正数，如果信号量是-1,就代表已经用完了信号量，其他线程需要阻塞了</p><p>第二个方法是semaphore.release()，代表是释放一个信号量，此时信号量的个数+1</p><p><strong>面试官</strong>：好的，那该如何保证Java程序在多线程的情况下执行安全呢？</p><p><strong>候选人</strong>：</p><p>嗯，刚才讲过了导致线程安全的原因，如果解决的话，jdk中也提供了很多的类帮助我们解决多线程安全的问题，比如：</p><ul><li>JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题</li><li>synchronized、volatile、LOCK，可以解决可见性问题</li><li>Happens-Before 规则可以解决有序性问题</li></ul><hr><p><strong>面试官</strong>：你在项目中哪里用了多线程？</p><p><strong>候选人</strong>：</p><p>嗯~~，我想一下当时的场景[根据自己简历上的模块设计多线程场景]</p><p>参考场景一：</p><p>es数据批量导入</p><p>在我们项目上线之前，我们需要把数据量的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），如果分批执行的话，耗时也太久了。所以，当时我就想到可以使用线程池的方式导入，利用CountDownLatch+Future来控制，就能大大提升导入的时间。</p><p>参考场景二：</p><p>在我做那个xx电商网站的时候，里面有一个数据汇总的功能，在用户下单之后需要查询订单信息，也需要获得订单中的商品详细信息（可能是多个），还需要查看物流发货信息。因为它们三个对应的分别三个微服务，如果一个一个的操作的话，互相等待的时间比较长。所以，我当时就想到可以使用线程池，让多个线程同时处理，最终再汇总结果就可以了，当然里面需要用到Future来获取每个线程执行之后的结果才行</p><p>参考场景三：</p><p>《黑马头条》项目中使用的</p><p>我当时做了一个文章搜索的功能，用户输入关键字要搜索文章，同时需要保存用户的搜索记录（搜索历史），这块我设计的时候，为了不影响用户的正常搜索，我们采用的异步的方式进行保存的，为了提升性能，我们加入了线程池，也就说在调用异步方法的时候，直接从线程池中获取线程使用</p></blockquote><h3 id="6-5-其他"><a href="#6-5-其他" class="headerlink" title="6.5 其他"></a>6.5 其他</h3><blockquote><p><strong>面试官</strong>：谈谈你对ThreadLocal的理解</p><p><strong>候选人</strong>：</p><p>嗯，是这样的~~</p><p>ThreadLocal 主要功能有两个，第一个是可以实现资源对象的线程隔离，让每个线程各用各的资源对象，避免争用引发的线程安全问题，第二个是实现了线程内的资源共享</p><p><strong>面试官</strong>：好的，那你知道ThreadLocal的底层原理实现吗？</p><p><strong>候选人</strong>：</p><p>嗯，知道一些~</p><p>在ThreadLocal内部维护了一个一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p><p>当我们调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</p><p>当调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</p><p>当调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</p><p><strong>面试官</strong>：好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？</p><p><strong>候选人</strong>：</p><p>嗯，我之前看过源码，我想一下~~</p><p>是应为ThreadLocalMap 中的 key 被设计为弱引用，它是被动的被GC调用释放key，不过关键的是只有key可以得到内存释放，而value不会，因为value是一个强引用。</p><p>在使用ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收，建议主动的remove 释放 key，这样就能避免内存溢出。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见技术场景</title>
      <link href="/2023/10/18/%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF/"/>
      <url>/2023/10/18/%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="常见技术场景"><a href="#常见技术场景" class="headerlink" title="常见技术场景"></a>常见技术场景</h2><h3 id="1-单点登录这块怎么实现的"><a href="#1-单点登录这块怎么实现的" class="headerlink" title="1.单点登录这块怎么实现的"></a>1.单点登录这块怎么实现的</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>单点登录的英文名叫做：Single Sign On（简称<strong>SSO</strong>）,只需要登录一次，就可以访问所有信任的应用系统</p><p>在<strong>以前</strong>的时候，一般我们就<strong>单系统</strong>，所有的功能都在同一个系统上。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223617.png" alt="image-20230521113500488"></p><p>单体系统的session共享</p><ul><li><p><strong>登录</strong>：将用户信息保存在Session对象中</p></li><li><ul><li>如果在Session对象中能查到，说明已经登录</li><li>如果在Session对象中查不到，说明没登录（或者已经退出了登录）</li></ul></li><li><p><strong>注销（退出登录）</strong>：从Session中删除用户的信息</p></li></ul><p>后来，我们为了<strong>合理利用资源和降低耦合性</strong>，于是把单系统<strong>拆分</strong>成多个子系统。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223618.png" alt="image-20230521113544219"></p><p>多系统即可能有多个Tomcat，而Session是依赖当前系统的Tomcat，所以系统A的Session和系统B的Session是<strong>不共享</strong>的。</p><p>解决系统之间Session不共享问题有一下几种方案：</p><ul><li>Tomcat集群Session全局复制（最多支持5台tomcat，不推荐使用）</li><li>JWT(常见)</li><li>Oauth2</li><li>CAS</li><li>自己实现（redis+token）</li></ul><h4 id="1-2-JWT解决单点登录"><a href="#1-2-JWT解决单点登录" class="headerlink" title="1.2 JWT解决单点登录"></a>1.2 JWT解决单点登录</h4><p>现在有一个微服务的简单架构，如图：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223619.png" alt="image-20230521113906521"></p><p>使用jwt解决单点登录的流程如下：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223620.png" alt="image-20230521113941467"></p><h4 id="1-3-回答要点"><a href="#1-3-回答要点" class="headerlink" title="1.3 回答要点"></a>1.3 回答要点</h4><p>1，先解释什么是单点登录</p><p>单点登录的英文名叫做：Single Sign On（简称<strong>SSO</strong>）</p><p>2，介绍自己项目中涉及到的单点登录（即使没涉及过，也可以说实现的思路）</p><p>3，介绍单点登录的解决方案，以JWT为例</p><p>​   I.  用户访问其他系统，会在网关判断token是否有效</p><p>​     II.  如果token无效则会返回401（认证失败）前端跳转到登录页面</p><p>​    III.  用户发送登录请求，返回浏览器一个token，浏览器把token保存到cookie</p><p>​    IV.  再去访问其他服务的时候，都需要携带token，由网关统一验证后路由到目标服务</p><h3 id="2-权限认证是如何实现的"><a href="#2-权限认证是如何实现的" class="headerlink" title="2.权限认证是如何实现的"></a>2.权限认证是如何实现的</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>后台的管理系统，更注重权限控制，最常见的就是RBAC模型来指导实现权限</p><p>RBAC(Role-Based Access Control)基于角色的访问控制</p><ul><li><p>3个基础部分组成：用户、角色、权限</p></li><li><p>具体实现</p><ul><li>5张表（用户表、角色表、权限表、用户角色中间表、角色权限中间表）</li><li>7张表（用户表、角色表、权限表、菜单表、用户角色中间表、角色权限中间表、权限菜单中间表）</li></ul></li></ul><h4 id="2-2-RBAC权限模型"><a href="#2-2-RBAC权限模型" class="headerlink" title="2.2 RBAC权限模型"></a>2.2 RBAC权限模型</h4><p>最常见的5张表的关系</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223621.png" alt="image-20230521114305463"></p><p><strong>数据流转</strong></p><p>张三具有什么权限呢？</p><p>流程：张三登录系统—&gt; 查询张三拥有的角色列表—&gt;再根据角色查询拥有的权限</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223622.png" alt="image-20230521114432028"></p><p>在实际的开发中，也会使用权限框架完成权限功能的实现，并且设置多种粒度，常见的框架有：</p><ul><li>Apache shiro  </li><li>Spring security（推荐）</li></ul><h4 id="2-3-回答要点"><a href="#2-3-回答要点" class="headerlink" title="2.3 回答要点"></a>2.3 回答要点</h4><ul><li><p>后台管理系统的开发经验</p></li><li><p>介绍RBAC权限模型5张表的关系（用户、角色、权限）</p></li><li><p>权限框架：Spring security</p></li></ul><h3 id="3-上传数据的安全性你们怎么控制？"><a href="#3-上传数据的安全性你们怎么控制？" class="headerlink" title="3.上传数据的安全性你们怎么控制？"></a>3.上传数据的安全性你们怎么控制？</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223623.png" alt="image-20230521124717749"></p><blockquote><p>这里的安全性，主要说的是，浏览器访问后台，需要经过网络传输，有可能会出现安全的问题</p></blockquote><p>解决方案：使用非对称加密（或对称加密），给前端一个公钥让他把数据加密后传到后台，后台负责解密后处理数据</p><h4 id="3-2-对称加密"><a href="#3-2-对称加密" class="headerlink" title="3.2 对称加密"></a>3.2 对称加密</h4><p>文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223624.png" alt="image-20230521125012727"></p><ul><li><p>数据发信方将明文和加密密钥一起经过特殊的加密算法处理后，使其变成复杂的加密密文发送出去，</p></li><li><p>收信方收到密文后，若想解读出原文，则需要使用加密时用的密钥以及相同加密算法的逆算法对密文进行解密，才能使其回复成可读明文。</p></li><li><p>在对称加密算法中，使用的密钥只有一个，收发双方都使用这个密钥，这就需要解密方事先知道加密密钥。</p></li></ul><p><strong>优点:</strong>  对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。</p><p><strong>缺点:</strong>  没有非对称加密安全.</p><p><strong>用途：</strong> 一般用于保存用户手机号、身份证等敏感但能解密的信息。</p><p><strong>常见的对称加密算法有</strong>: <code>AES、DES、3DES、Blowfish、IDEA、RC4、RC5、RC6、HS256 </code></p><h4 id="3-3-非对称加密"><a href="#3-3-非对称加密" class="headerlink" title="3.3 非对称加密"></a>3.3 非对称加密</h4><p>两个密钥：公开密钥（publickey）和私有密钥，公有密钥加密，私有密钥解密</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223625.png" alt="image-20230521125136717"></p><p>解释:  同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端.</p><p>加密与解密:</p><ul><li>私钥加密，持有公钥才可以解密</li><li>公钥加密，持有私钥才可解密</li></ul><p>签名:</p><ul><li>私钥签名,  持有公钥进行验证是否被篡改过.</li></ul><p>**优点: ** 非对称加密与对称加密相比，其安全性更好；</p><p><strong>缺点:</strong>  非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。<br><strong>用途：</strong> 一般用于签名和认证。私钥服务器保存, 用来加密,  公钥客户拿着用于对于令牌或者签名的解密或者校验使用.</p><p><strong>常见的非对称加密算法有：</strong> RSA、DSA（数字签名用）、ECC（移动设备用）、RS256 (采用SHA-256 的 RSA 签名) </p><h4 id="3-4-回答要点"><a href="#3-4-回答要点" class="headerlink" title="3.4 回答要点"></a>3.4 回答要点</h4><ul><li>使用非对称加密（或对称加密），给前端一个公钥让他把数据加密后传到后台，后台解密后处理数据<ul><li>传输的数据很大建议使用对称加密，不过不能保存敏感信息</li><li>传输的数据较小，要求安全性高，建议采用非对称加密</li></ul></li></ul><h3 id="4-你负责项目的时候遇到了哪些比较棘手的问题"><a href="#4-你负责项目的时候遇到了哪些比较棘手的问题" class="headerlink" title="4.你负责项目的时候遇到了哪些比较棘手的问题"></a>4.你负责项目的时候遇到了哪些比较棘手的问题</h3><p>这个面试题主要考察的是，</p><ul><li>你是否有过开发经验</li><li>是否是核心开发人员</li></ul><p>有4个方面可以回答，只要挑出一个回答就行了</p><p><strong>（1）设计模式</strong></p><ul><li>工厂模式+策略</li><li>责任链模式</li></ul><blockquote><p>回答思路</p><p>1，什么背景（技术问题）</p><p>2，过程（解决问题的过程）</p><p>3，最终落地方案</p></blockquote><p>举例：</p><p>①：介绍登录业务（一开始没有用设计模式，所有的登录方式都柔和在一个业务类中，不过，发现需求经常改）</p><p>②：登录方式经常会增加或更换，每次都要修改业务层代码，所以，经过我的设计，使用了工厂设计模式和策略模式，解决了，经常修改业务层代码的问题</p><p>③：详细介绍一下工厂模式和策略模式（参考前面设计模式的课程）</p><p><strong>（2）线上BUG</strong></p><ul><li>CPU飙高</li><li>内存泄漏</li><li>线程死锁</li><li>….</li></ul><p>回答方式参考上面的回答思路，具体问题可以参考前面的课程（JVM和多线程相关的面试题）</p><p><strong>（3）调优</strong></p><ul><li>慢接口</li><li>慢SQL</li><li>缓存方案</li></ul><p><strong>（4）组件封装</strong></p><ul><li>分布式锁</li><li>接口幂等</li><li>分布式事务</li><li>支付通用</li></ul><h3 id="5-你们项目中日志怎么采集的"><a href="#5-你们项目中日志怎么采集的" class="headerlink" title="5.你们项目中日志怎么采集的"></a>5.你们项目中日志怎么采集的</h3><h4 id="5-1-问题"><a href="#5-1-问题" class="headerlink" title="5.1 问题"></a>5.1 问题</h4><p>1，为什么要采集日志？</p><p>日志是定位系统问题的重要手段，可以根据日志信息快速定位系统中的问题</p><p>2，采集日志的方式有哪些?</p><ul><li><p>ELK：即Elasticsearch、Logstash和Kibana三个软件的首字母</p></li><li><p>常规采集：按天保存到一个日志文件<img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223626.png" alt="image-20230521232726959"></p></li></ul><h4 id="5-2-ELK基本架构"><a href="#5-2-ELK基本架构" class="headerlink" title="5.2 ELK基本架构"></a>5.2 ELK基本架构</h4><p>ELK即Elasticsearch、Logstash和Kibana三个开源软件的缩写</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223627.png" alt="image-20230521232913086"></p><ul><li><p>Elasticsearch<br>Elasticsearch  全文搜索和分析引擎，对大容量的数据进行接近实时的存储、搜索和分析操作。</p></li><li><p>Logstash<br>Logstash是一个数据收集引擎，它可以动态的从各种数据源搜集数据，并对数据进行过滤、分析和统一格式等操作，并将输出结果存储到指定位置上</p></li><li><p>Kibana<br>Kibana是一个数据分析和可视化平台，通常与Elasticsearch配合使用，用于对其中的数据进行搜索、分析，并且以统计图标的形式展示。</p></li></ul><h4 id="5-3-参考回答"><a href="#5-3-参考回答" class="headerlink" title="5.3 参考回答"></a>5.3 参考回答</h4><ul><li><p>我们搭建了ELK日志采集系统</p></li><li><p>介绍ELK的三个组件：</p><ul><li>Elasticsearch是全文搜索分析引擎，可以对数据存储、搜索、分析</li><li>Logstash是一个数据收集引擎，可以动态收集数据，可以对数据进行过滤、分析，将数据存储到指定的位置</li><li>Kibana是一个数据分析和可视化平台，配合Elasticsearch对数据进行搜索，分析，图表化展示</li></ul></li></ul><h3 id="6-查看日志的命令"><a href="#6-查看日志的命令" class="headerlink" title="6.查看日志的命令"></a>6.查看日志的命令</h3><p>目前采集日志的方式：按天保存到一个日志文件</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223628.png" alt="image-20230521233150276"></p><p>也可以在logback配置文件中设置日志的目录和名字</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223629.png" alt="image-20230521233220905"></p><p>需要掌握的Linux中的日志：</p><ul><li><p>实时监控日志的变化</p><p>实时监控某一个日志文件的变化：tail -f xx.log；实时监控日志最后100行日志： tail –n 100 -f xx.log</p></li><li><p>按照行号查询</p><ul><li><p>查询日志尾部最后100行日志：tail – n 100 xx.log</p></li><li><p>查询日志头部开始100行日志：head –n 100 xx.log</p></li><li><p>查询某一个日志行号区间：cat -n xx.log | tail -n +100 | head -n 100 (查询100行至200行的日志)</p></li></ul></li><li><p>按照关键字找日志的信息</p><p>查询日志文件中包含debug的日志行号：cat -n xx.log | grep “debug”</p></li><li><p>按照日期查询</p><p>sed -n ‘&#x2F;2023-05-18 14:22:31.070&#x2F;,&#x2F; 2023-05-18 14:27:14.158&#x2F;p’xx.log </p></li><li><p>日志太多，处理方式</p><ul><li><p>分页查询日志信息：cat -n xx.log |grep “debug” | more</p></li><li><p>筛选过滤以后，输出到一个文件：cat -n xx.log | grep “debug” &gt;debug.txt</p></li></ul></li></ul><h3 id="7-生产问题怎么排查"><a href="#7-生产问题怎么排查" class="headerlink" title="7.生产问题怎么排查"></a>7.生产问题怎么排查</h3><p>已经上线的bug排查的思路：</p><p>1，先分析日志，通常在业务中都会有日志的记录，或者查看系统日志，或者查看日志文件，然后定位问题</p><p>2，远程debug(通常公司的正式环境（生产环境）是不允许远程debug的。一般远程debug都是公司的测试环境，方便调试代码)</p><p><strong>远程debug配置</strong></p><p>前提条件：<strong>远程的代码和本地的代码要保持一致</strong></p><p>1.远程代码需要配置启动参数，把项目打包放到服务器后启动项目的参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 project-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><blockquote><p><strong>-agentlib:jdwp</strong>  是通知JVM使用(java debug wire protocol)来运行调试环境</p><p><strong>transport&#x3D;dt_socket</strong>  调试数据的传送方式</p><p><strong>server&#x3D;y</strong>  参数是指是否支持在server模式</p><p><strong>suspend&#x3D;n</strong> 是否在调试客户端建立起来后，再执行JVM。</p><p><strong>address&#x3D;5005</strong>  调试端口设置为5005，其它端口也可以</p></blockquote><p>2.idea中设置远程debug，找到idea中的 Edit Configurations…</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223630.png" alt="image-20230521233554657"></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223631.png" alt="image-20230521233600556"></p><ol start="3"><li>idea中启动远程debug<img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223632.png" alt="image-20230521233715574"></li><li>访问远程服务器，在本地代码中打断点即可调试远程</li></ol><h3 id="8-怎么快速定位系统的瓶颈"><a href="#8-怎么快速定位系统的瓶颈" class="headerlink" title="8.怎么快速定位系统的瓶颈"></a>8.怎么快速定位系统的瓶颈</h3><ul><li><p>压测（性能测试），项目上线之前测评系统的压力</p><ul><li>压测目的：给出系统当前的性能状况；定位系统性能瓶颈或潜在性能瓶颈</li><li>指标：响应时间、 QPS、并发数、吞吐量、 CPU利用率、内存使用率、磁盘IO、错误率</li><li>压测工具：LoadRunner、Apache Jmeter …</li><li>后端工程师：根据压测的结果进行解决或调优（接口慢、代码报错、并发达不到要求…）</li></ul></li><li><p>监控工具、链路追踪工具，项目上线之后监控</p><ul><li>监控工具：Prometheus+Grafana</li><li>链路追踪工具：skywalking、Zipkin</li></ul></li><li><p>线上诊断工具Arthas(阿尔萨斯)，项目上线之后监控、排查</p><ul><li><p>官网：<a href="https://arthas.aliyun.com/">https://arthas.aliyun.com/</a></p></li><li><p>核心功能：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223633.png" alt="image-20230521233926897"></p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211223634.png" alt="image-20230521233934644"></p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2023/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="面试专题-设计模式"><a href="#面试专题-设计模式" class="headerlink" title="面试专题-设计模式"></a>面试专题-设计模式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在平时的开发中，涉及到设计模式的有两块内容，第一个是我们平时使用的框架（比如spring、mybatis等），第二个是我们自己开发业务使用的设计模式。</p><p>面试官一般比较关心的是你在开发过程中，有没有使用过设计模式，或者你在简历上写了关于设计模式的描述，那么这样我们就需要重点关心自己开发中用过的设计模式。</p><p>在平时的业务开发中，其实真正使用设计模式的场景并不多，虽然设计号称有23种之多（不同的纬度可能会更多），但是在项目最常使用的也就几种而已，在面试的过程中，我们主要介绍一种或两种就可以，重点要说的是：在什么业务场景下使用了设计模式，什么设计模式？</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222050.png" alt="image-20230521101639915"></p><p>这次面试部分，我们主要介绍三种设计模式：</p><ul><li>工厂方法模式（简单工厂、工厂方法、抽象工厂）</li><li>策略模式</li><li>责任链模式</li></ul><h2 id="1-工厂方法模式"><a href="#1-工厂方法模式" class="headerlink" title="1 工厂方法模式"></a>1 工厂方法模式</h2><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>需求：设计一个咖啡店点餐系统。  </p><p>设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。</p><p>具体类的设计如下：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222052.jpg"></p><blockquote><p>1.类图中的符号</p><ul><li>+：表示public</li><li>-：表示private</li><li>#：表示protected</li></ul><p>2.泛化关系(继承)用带空心三角箭头的实线来表示</p><p>3.依赖关系使用带箭头的虚线来表示</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.factory.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> orderCoffee(<span class="string">&quot;latte&quot;</span>);</span><br><span class="line">        System.out.println(coffee.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;american&quot;</span>.equals(type))&#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;latte&quot;</span>.equals(type))&#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加配料</span></span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addSuqar();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的<strong>开闭原则</strong>。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：<strong>解耦</strong>。</p><blockquote><p>开闭原则：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p></blockquote><p>三种工厂</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><h4 id="1-2-简单工厂模式"><a href="#1-2-简单工厂模式" class="headerlink" title="1.2 简单工厂模式"></a>1.2 简单工厂模式</h4><p>简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p><h5 id="1-2-1-结构"><a href="#1-2-1-结构" class="headerlink" title="1.2.1 结构"></a>1.2.1 结构</h5><p>简单工厂包含如下角色：</p><ul><li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品 ：实现或者继承抽象产品的子类</li><li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li></ul><h5 id="1-2-2-实现"><a href="#1-2-2-实现" class="headerlink" title="1.2.2 实现"></a>1.2.2 实现</h5><p>现在使用简单工厂对上面案例进行改进，类图如下：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222053.png" alt="image-20230521102022928"></p><p>工厂类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咖啡店</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.factory.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="comment">//通过工厂获得对象，不需要知道对象实现的细节</span></span><br><span class="line">        <span class="type">SimpleCoffeeFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCoffeeFactory</span>();</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> factory.createCoffee(type);</span><br><span class="line">        <span class="comment">//添加配料</span></span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addSuqar();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。</p><p>后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。</p><h5 id="1-2-3-优缺点"><a href="#1-2-3-优缺点" class="headerlink" title="1.2.3 优缺点"></a>1.2.3 优缺点</h5><p><strong>优点：</strong></p><p>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</p><p><strong>缺点：</strong></p><p>增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。</p><h5 id="1-2-4-扩展"><a href="#1-2-4-扩展" class="headerlink" title="1.2.4 扩展"></a>1.2.4 扩展</h5><p><strong>静态工厂</strong></p><p>在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-工厂方法模式"><a href="#1-3-工厂方法模式" class="headerlink" title="1.3 工厂方法模式"></a>1.3 工厂方法模式</h4><p>针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p><h5 id="1-3-1-概念"><a href="#1-3-1-概念" class="headerlink" title="1.3.1 概念"></a>1.3.1 概念</h5><p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p><h5 id="1-3-2-结构"><a href="#1-3-2-结构" class="headerlink" title="1.3.2 结构"></a>1.3.2 结构</h5><p>工厂方法模式的主要角色：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ul><h5 id="1-3-3-实现"><a href="#1-3-3-实现" class="headerlink" title="1.3.3 实现"></a>1.3.3 实现</h5><p>使用工厂方法模式对上例进行改进，类图如下：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222054.png" alt="image-20230521102122950"></p><p>流程：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222055.png" alt="image-20230521102156863"></p><p>代码如下：</p><p>抽象工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咖啡店类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CoffeeFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CoffeeStore</span><span class="params">(CoffeeFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> factory.createCoffee();</span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addsugar();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。</p><p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p><h5 id="1-3-4-优缺点"><a href="#1-3-4-优缺点" class="headerlink" title="1.3.4 优缺点"></a>1.3.4 优缺点</h5><p><strong>优点：</strong></p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li></ul><p><strong>缺点：</strong></p><ul><li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li></ul><h4 id="1-4-抽象工厂模式"><a href="#1-4-抽象工厂模式" class="headerlink" title="1.4 抽象工厂模式"></a>1.4 抽象工厂模式</h4><p>前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。</p><p>这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p><p>本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示</p><ul><li>产品族：一个品牌下面的所有产品；例如华为下面的电脑、手机称为华为的产品族；</li><li>产品等级：多个品牌下面的同种产品；例如华为和小米都有手机电脑为一个产品等级；</li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222056.png" alt="image-20220913115948157"></p><h5 id="1-4-1-概念"><a href="#1-4-1-概念" class="headerlink" title="1.4.1 概念"></a>1.4.1 概念</h5><p>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><p><strong>一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂</strong></p><h5 id="1-4-2-结构"><a href="#1-4-2-结构" class="headerlink" title="1.4.2 结构"></a>1.4.2 结构</h5><p>抽象工厂模式的主要角色如下：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li></ul><h5 id="1-4-3-实现"><a href="#1-4-3-实现" class="headerlink" title="1.4.3 实现"></a>1.4.3 实现</h5><p>现咖啡店业务发生改变，不仅要生产<strong>咖啡</strong>还要生产<strong>甜点</strong></p><ul><li>同一个产品等级（产品分类）<ul><li>咖啡：拿铁咖啡、美式咖啡 </li><li>甜点：提拉米苏、抹茶慕斯</li></ul></li><li>同一个风味，就是同一个产品族（相当于同一个品牌）<ul><li>美式风味：美式咖啡、抹茶慕斯</li><li>意大利风味：拿铁咖啡、提拉米苏</li></ul></li></ul><p>要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。</p><p>所以这个案例可以使用抽象工厂模式实现。类图如下：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222057.png" alt="image-20230521102319997"></p><blockquote><p>实现关系使用带空心三角箭头的虚线来表示</p></blockquote><p>整体调用思路：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222058.png" alt="image-20220913124542154"></p><h5 id="1-4-4-优缺点"><a href="#1-4-4-优缺点" class="headerlink" title="1.4.4 优缺点"></a>1.4.4 优缺点</h5><p><strong>优点：</strong></p><p>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong></p><p>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p><h5 id="1-4-5-使用场景"><a href="#1-4-5-使用场景" class="headerlink" title="1.4.5 使用场景"></a>1.4.5 使用场景</h5><ul><li><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</p></li><li><p>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</p></li><li><p>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</p></li></ul><p>如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。</p><h2 id="2-策略模式"><a href="#2-策略模式" class="headerlink" title="2 策略模式"></a>2 策略模式</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222059.png" alt="image-20230521102452501"></p><p>作为一个程序猿，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，可以选择Idea进行开发，也可以使用eclipse进行开发，也可以使用其他的一些开发工具。</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222060.png" alt="image-20220913125131383"></p><p><strong>定义：</strong></p><p>​该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p><h3 id="2-2-结构"><a href="#2-2-结构" class="headerlink" title="2.2 结构"></a>2.2 结构</h3><p>策略模式的主要角色如下：</p><ul><li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ul><h3 id="2-3-案例实现"><a href="#2-3-案例实现" class="headerlink" title="2.3 案例实现"></a>2.3 案例实现</h3><p>【例】促销活动</p><p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222061.png" alt="image-20220913125209804"></p><blockquote><p>聚合关系可以用带空心菱形的实线来表示</p></blockquote><p>代码如下：</p><p>定义百货公司所有促销活动的共同接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为春节准备的促销活动A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为中秋准备的促销活动B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满200元减50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为圣诞准备的促销活动C</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalesMan</span> &#123;                        </span><br><span class="line">    <span class="comment">//持有抽象策略角色的引用                              </span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;                 </span><br><span class="line">                                               </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SalesMan</span><span class="params">(Strategy strategy)</span> &#123;       </span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;              </span><br><span class="line">    &#125;                                          </span><br><span class="line">                                               </span><br><span class="line">    <span class="comment">//向客户展示促销活动                                </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">salesManShow</span><span class="params">()</span>&#123;                </span><br><span class="line">        strategy.show();                       </span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125;                                              </span><br></pre></td></tr></table></figure><h3 id="2-4-综合案例"><a href="#2-4-综合案例" class="headerlink" title="2.4 综合案例"></a>2.4 综合案例</h3><h4 id="2-4-1-概述"><a href="#2-4-1-概述" class="headerlink" title="2.4.1 概述"></a>2.4.1 概述</h4><p>下图是gitee的登录的入口，其中有多种方式可以进行登录</p><ul><li><p>用户名密码登录</p></li><li><p>短信验证码登录</p></li><li><p>微信登录</p></li><li><p>QQ登录</p></li><li><p>….</p></li></ul><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222062.png" alt="image-20230521104504491"></p><h4 id="2-4-2-目前已实现的代码"><a href="#2-4-2-目前已实现的代码" class="headerlink" title="2.4.2 目前已实现的代码"></a>2.4.2 目前已实现的代码</h4><p>(1)登录接口</p><table><thead><tr><th></th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>POST</td></tr><tr><td>路径</td><td>&#x2F;api&#x2F;user&#x2F;login</td></tr><tr><td>参数</td><td>LoginReq</td></tr><tr><td>返回值</td><td>LoginResp</td></tr></tbody></table><p>请求参数：LoginReq</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginReq</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String validateCode;<span class="comment">//手机验证码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String wxCode;<span class="comment">//用于微信登录</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * account : 用户名密码登录</span></span><br><span class="line"><span class="comment">     * sms : 手机验证码登录</span></span><br><span class="line"><span class="comment">     * we_chat : 微信登录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应参数：LoginResp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginResp</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String roleCode;</span><br><span class="line">    <span class="keyword">private</span> String token; <span class="comment">//jwt令牌</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> success;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制层LoginController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginReq loginReq)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.login(loginReq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务层UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(loginReq.getType().equals(<span class="string">&quot;account&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名密码登录&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行用户密码登录逻辑</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(loginReq.getType().equals(<span class="string">&quot;sms&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;手机号验证码登录&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行手机号验证码登录逻辑</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (loginReq.getType().equals(<span class="string">&quot;we_chat&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;微信登录&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行用户微信登录逻辑</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LoginResp</span> <span class="variable">loginResp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">        loginResp.setSuccess(<span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> loginResp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：我们重点讲的是设计模式，并不是登录的逻辑，所以以上代码并没有真正的实现登录功能</p></blockquote><p>(2)问题分析</p><ul><li>业务层代码大量使用到了if…else，在后期阅读代码的时候会非常不友好，大量使用if…else性能也不高</li><li>如果业务发生变更，比如现在新增了QQ登录方式，这个时候需要修改业务层代码，违反了开闭原则</li></ul><p>解决：</p><p>使用<strong>工厂方法设计模式+策略模式</strong>解决</p><h4 id="2-4-3-代码改造（工厂-策略）"><a href="#2-4-3-代码改造（工厂-策略）" class="headerlink" title="2.4.3 代码改造（工厂+策略）"></a>2.4.3 代码改造（工厂+策略）</h4><p>（1）整体思路</p><p>改造之后，不在service中写业务逻辑，让service调用工厂，然后通过service传递不同的参数来获取不同的登录策略（登录方式）</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222063.png" alt="image-20230521105346337"></p><p>（2）具体实现</p><p>抽象策略类：UserGranter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象策略类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserGranter</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loginReq 传入的参数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> map值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的策略：AccountGranter、SmsGranter、WeChatGranter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略：账号登录</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountGranter</span> <span class="keyword">implements</span> <span class="title class_">UserGranter</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span> &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;登录方式为账号登录&quot;</span> + loginReq);</span><br><span class="line"><span class="comment">// TODO</span></span><br><span class="line"><span class="comment">// 执行业务操作 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略:短信登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsGranter</span> <span class="keyword">implements</span> <span class="title class_">UserGranter</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span>  &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;登录方式为短信登录&quot;</span> + loginReq);</span><br><span class="line"><span class="comment">// TODO</span></span><br><span class="line"><span class="comment">// 执行业务操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略:微信登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatGranter</span> <span class="keyword">implements</span> <span class="title class_">UserGranter</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span>  &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;登录方式为微信登录&quot;</span> + loginReq);</span><br><span class="line"><span class="comment">// TODO</span></span><br><span class="line"><span class="comment">// 执行业务操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工程类：UserLoginFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作策略的上下文环境类 工具类</span></span><br><span class="line"><span class="comment"> * 将策略整合起来 方便管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserLoginFactory</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, UserGranter&gt; granterPool = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginTypeConfig loginTypeConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置文件中读取策略信息存储到map中</span></span><br><span class="line"><span class="comment">     * &#123;</span></span><br><span class="line"><span class="comment">     * account:accountGranter,</span></span><br><span class="line"><span class="comment">     * sms:smsGranter,</span></span><br><span class="line"><span class="comment">     * we_chat:weChatGranter</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        loginTypeConfig.getTypes().forEach((k, y) -&gt; &#123;</span><br><span class="line">            granterPool.put(k, (UserGranter) applicationContext.getBean(y));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外提供获取具体策略</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> grantType 用户的登录方式，需要跟配置文件中匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 具体策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> UserGranter <span class="title function_">getGranter</span><span class="params">(String grantType)</span> &#123;</span><br><span class="line">        <span class="type">UserGranter</span> <span class="variable">tokenGranter</span> <span class="operator">=</span> granterPool.get(grantType);</span><br><span class="line">        <span class="keyword">return</span> tokenGranter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在application.yml文件中新增自定义配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">login:</span></span><br><span class="line">  <span class="attr">types:</span></span><br><span class="line">    <span class="attr">account:</span> <span class="string">accountGranter</span></span><br><span class="line">    <span class="attr">sms:</span> <span class="string">smsGranter</span></span><br><span class="line">    <span class="attr">we_chat:</span> <span class="string">weChatGranter</span></span><br></pre></td></tr></table></figure><p>新增读取数据配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Getter</span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginTypeConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; types;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改造service代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserLoginFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">UserGranter</span> <span class="variable">granter</span> <span class="operator">=</span> factory.getGranter(loginReq.getType());</span><br><span class="line">        <span class="keyword">if</span>(granter == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">LoginResp</span> <span class="variable">loginResp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">            loginResp.setSuccess(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> loginResp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LoginResp</span> <span class="variable">loginResp</span> <span class="operator">=</span> granter.login(loginReq);</span><br><span class="line">        <span class="keyword">return</span> loginResp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以看到我们使用了设计模式之后，业务层的代码就清爽多了，如果后期有新的需求改动，比如加入了QQ登录，我们只需要添加对应的策略就可以，无需再改动业务层代码。</p><h4 id="2-4-4-举一反三"><a href="#2-4-4-举一反三" class="headerlink" title="2.4.4 举一反三"></a>2.4.4 举一反三</h4><p>其实像这样的需求，在日常开发中非常常见，场景有很多，以下的情景都可以使用工厂模式+策略模式解决比如：</p><ul><li>订单的支付策略<ul><li>支付宝支付</li><li>微信支付</li><li>银行卡支付</li><li>现金支付</li></ul></li><li>解析不同类型excel<ul><li>xls格式</li><li>xlsx格式</li></ul></li><li>打折促销<ul><li>满300元9折</li><li>满500元8折</li><li>满1000元7折</li></ul></li><li>物流运费阶梯计算<ul><li>5kg以下</li><li>5kg-10kg</li><li>10kg-20kg</li><li>20kg以上</li></ul></li></ul><p>一句话总结：<strong>只要代码中有冗长的 if-else 或 switch 分支判断都可以采用策略模式优化</strong></p><h2 id="3-责任链设计模式"><a href="#3-责任链设计模式" class="headerlink" title="3 责任链设计模式"></a>3 责任链设计模式</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。</p><p><strong>定义：</strong></p><p>又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p>比较常见的springmvc中的拦截器，web开发中的filter过滤器</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222064.png" alt="image-20230521111455359"></p><h3 id="3-2-结构"><a href="#3-2-结构" class="headerlink" title="3.2 结构"></a>3.2 结构</h3><p>职责链模式主要包含以下角色:</p><ul><li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li><li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li></ul><h3 id="3-2-案例实现"><a href="#3-2-案例实现" class="headerlink" title="3.2 案例实现"></a>3.2 案例实现</h3><p>处理订单的操作</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222065.png" alt="image-20230521111943231"></p><p>类图：</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222066.png" alt="image-20230521112108550"></p><p>代码：</p><p>抽象处理者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.designpattern.chain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象处理者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Handler handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理过程</span></span><br><span class="line"><span class="comment">     * 需要子类进行实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(OrderInfo order)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订单信息类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.designpattern.chain;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProductId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductId</span><span class="params">(String productId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserId</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getAmount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAmount</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体处理者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单校验</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderValidition</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(OrderInfo order)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;校验订单基本信息&quot;</span>);</span><br><span class="line">        <span class="comment">//校验</span></span><br><span class="line">        handler.process(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 补充订单信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFill</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(OrderInfo order)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;补充订单信息&quot;</span>);</span><br><span class="line">        handler.process(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算金额</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderAmountCalcuate</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(OrderInfo order)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算金额-优惠券、VIP、活动打折&quot;</span>);</span><br><span class="line">        handler.process(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单入库</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderCreate</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(OrderInfo order)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单入库&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//检验订单</span></span><br><span class="line">        <span class="type">Handler</span> <span class="variable">orderValidition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderValidition</span>();</span><br><span class="line">        <span class="comment">//补充订单信息</span></span><br><span class="line">        <span class="type">Handler</span> <span class="variable">orderFill</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderFill</span>();</span><br><span class="line">        <span class="comment">//订单算价</span></span><br><span class="line">        <span class="type">Handler</span> <span class="variable">orderAmountCalcuate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderAmountCalcuate</span>();</span><br><span class="line">        <span class="comment">//订单落库</span></span><br><span class="line">        <span class="type">Handler</span> <span class="variable">orderCreate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCreate</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置责任链路</span></span><br><span class="line">        orderValidition.setNext(orderFill);</span><br><span class="line">        orderFill.setNext(orderAmountCalcuate);</span><br><span class="line">        orderAmountCalcuate.setNext(orderCreate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始执行</span></span><br><span class="line">        orderValidition.process(<span class="keyword">new</span> <span class="title class_">OrderInfo</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-优缺点"><a href="#3-3-优缺点" class="headerlink" title="3.3 优缺点"></a>3.3 优缺点</h3><p><strong>优点</strong></p><ul><li><p>降低了对象之间的耦合度</p><p>该模式降低了请求发送者和接收者的耦合度。</p></li><li><p>增强了系统的可扩展性</p><p>可以根据需要增加新的请求处理类，满足开闭原则。</p></li><li><p>增强了给对象指派职责的灵活性</p><p>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</p></li><li><p>责任链简化了对象之间的连接</p><p>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</p></li><li><p>责任分担</p><p>每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p></li></ul><p><strong>缺点：</strong></p><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li></ul><h3 id="3-4-举一反三"><a href="#3-4-举一反三" class="headerlink" title="3.4 举一反三"></a>3.4 举一反三</h3><ul><li><p>内容审核（视频、文章、课程….）</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222067.png" alt="image-20230521112731617"></p></li><li><p>订单创建</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222068.png" alt="image-20230521112802886"></p></li><li><p>简易流程审批</p><p><img src="http://s2v2ho78s.hn-bkt.clouddn.com/gh/202310211222069.png" alt="image-20230521112831065"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL面试题</title>
      <link href="/2023/10/18/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/10/18/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL面试题-文稿"><a href="#MySQL面试题-文稿" class="headerlink" title="MySQL面试题-文稿"></a>MySQL面试题-文稿</h3><blockquote><p><strong>面试官：</strong>MySQL中，如何定位慢查询?</p><p><strong>候选人：</strong></p><p>嗯~，我们当时做压测的时候有的接口非常的慢，接口的响应时间超过了2秒以上，因为我们当时的系统部署了运维的监控系统Skywalking ，在展示的报表中可以看到是哪一个接口比较慢，并且可以分析这个接口哪部分比较慢，这里可以看到SQL的具体的执行时间，所以可以定位是哪个sql出了问题</p><p>如果，项目中没有这种运维的监控系统，其实在MySQL中也提供了慢日志查询的功能，可以在MySQL的系统配置文件中开启这个慢日志的功能，并且也可以设置SQL执行超过多少时间来记录到一个日志文件中，我记得上一个项目配置的是2秒，只要SQL执行的时间超过了2秒就会记录到日志文件中，我们就可以在日志文件找到执行比较慢的SQL了。</p><p><strong>面试官：</strong>那这个SQL语句执行很慢, 如何分析呢？</p><p><strong>候选人：</strong>如果一条sql执行很慢的话，我们通常会使用mysql自动的执行计划explain来去查看这条sql的执行情况，比如在这里面可以通过key和key_len检查是否命中了索引，如果本身已经添加了索引，也可以判断索引是否有失效的情况，第二个，可以通过type字段查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描，第三个可以通过extra建议来判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复</p><p><strong>面试官：</strong>了解过索引吗？（什么是索引）</p><p><strong>候选人：</strong>嗯，索引在项目中还是比较常见的，它是帮助MySQL高效获取数据的数据结构，主要是用来提高数据检索的效率，降低数据库的IO成本，同时通过索引列对数据进行排序，降低数据排序的成本，也能降低了CPU的消耗</p><p><strong>面试官：</strong>索引的底层数据结构了解过嘛 ? </p><p><strong>候选人：</strong>MySQL的默认的存储引擎InnoDB采用的B+树的数据结构来存储索引，选择B+树的主要的原因是：第一阶数更多，路径更短，第二个磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据，第三是B+树便于扫库和区间查询，叶子节点是一个双向链表</p><p><strong>面试官：</strong>B树和B+树的区别是什么呢？</p><p><strong>候选人</strong>：第一：在B树中，非叶子节点和叶子节点都会存放数据，而B+树的所有的数据都会出现在叶子节点，在查询的时候，B+树查找效率更加稳定</p><p>第二：在进行范围查询的时候，B+树效率更高，因为B+树都在叶子节点存储，并且叶子节点是一个双向链表</p><p><strong>面试官：</strong>什么是聚簇索引什么是非聚簇索引 ?</p><p><strong>候选人：</strong></p><p>好的~，聚簇索引主要是指数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个，一般情况下主键在作为聚簇索引的</p><p>非聚簇索引值的是数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个，一般我们自己定义的索引都是非聚簇索引</p><p><strong>面试官：</strong>知道什么是回表查询嘛 ?</p><p><strong>候选人：</strong>嗯，其实跟刚才介绍的聚簇索引和非聚簇索引是有关系的，回表的意思就是通过二级索引找到对应的主键值，然后再通过主键值找到聚集索引中所对应的整行数据，这个过程就是回表</p><p>【<strong>备注</strong>：如果面试官直接问回表，则需要先介绍聚簇索引和非聚簇索引】</p><p><strong>面试官：</strong>知道什么叫覆盖索引嘛 ? </p><p><strong>候选人：</strong>嗯~，清楚的</p><p>覆盖索引是指select查询语句使用了索引，在返回的列，必须在索引中全部能够找到，如果我们使用id查询，它会直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p><p>如果按照二级索引查询数据的时候，返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select *，尽量在返回的列中都包含添加索引的字段</p><p><strong>面试官：</strong>MYSQL超大分页怎么处理 ?</p><p><strong>候选人：</strong>嗯，超大分页一般都是在数据量比较大时，我们使用了limit分页查询，并且需要对数据进行排序，这个时候效率就很低，我们可以采用覆盖索引和子查询来解决</p><p>先分页查询数据的id字段，确定了id之后，再用子查询来过滤，只查询这个id列表中的数据就可以了</p><p>因为查询id的时候，走的覆盖索引，所以效率可以提升很多</p><p><strong>面试官：</strong>索引创建原则有哪些？</p><p><strong>候选人：</strong>嗯，这个情况有很多，不过都有一个大前提，就是表中的数据要超过10万以上，我们才会创建索引，并且添加索引的字段是查询比较频繁的字段，一般也是像作为查询条件，排序字段或分组的字段这些。</p><p>还有就是，我们通常创建索引的时候都是使用复合索引来创建，一条sql的返回值，尽量使用覆盖索引，如果字段的区分度不高的话，我们也会把它放在组合索引后面的字段。</p><p>如果某一个字段的内容较长，我们会考虑使用前缀索引来使用，当然并不是所有的字段都要添加索引，这个索引的数量也要控制，因为添加索引也会导致新增改的速度变慢。</p><p><strong>面试官：</strong>什么情况下索引会失效 ?</p><p><strong>候选人：</strong>嗯，这个情况比较多，我说一些自己的经验，以前遇到过的</p><p>比如，索引在使用的时候没有遵循最左匹配法则，第二个是，模糊查询，如果%号在前面也会导致索引失效。如果在添加索引的字段上进行了运算操作或者类型转换也都会导致索引失效。</p><p>我们之前还遇到过一个就是，如果使用了复合索引，中间使用了范围查询，右边的条件索引也会失效</p><p>所以，通常情况下，想要判断出这条sql是否有索引失效的情况，可以使用explain执行计划来分析</p><p><strong>面试官：</strong>sql的优化的经验</p><p><strong>候选人：</strong>嗯，这个在项目还是挺常见的，当然如果直说sql优化的话，我们会从这几方面考虑，比如</p><p>建表的时候、使用索引、sql语句的编写、主从复制，读写分离，还有一个是如果量比较大的话，可以考虑分库分表</p><p><strong>面试官：</strong>创建表的时候，你们是如何优化的呢？</p><p><strong>候选人：</strong>这个我们主要参考的阿里出的那个开发手册《嵩山版》，就比如，在定义字段的时候需要结合字段的内容来选择合适的类型，如果是数值的话，像tinyint、int 、bigint这些类型，要根据实际情况选择。如果是字符串类型，也是结合存储的内容来选择char和varchar或者text类型</p><p><strong>面试官：</strong>那在使用索引的时候，是如何优化呢？</p><p><strong>候选人：</strong>【参考索引创建原则    进行描述】</p><p><strong>面试官：</strong>你平时对sql语句做了哪些优化呢？</p><p><strong>候选人：</strong>嗯，这个也有很多，比如SELECT语句务必指明字段名称，不要直接使用select * ，还有就是要注意SQL语句避免造成索引失效的写法；如果是聚合查询，尽量用union all代替union ，union会多一次过滤，效率比较低；如果是表关联的话，尽量使用innerjoin ，不要使用用left join right join，如必须使用 一定要以小表为驱动</p><p><strong>面试官：</strong>事务的特性是什么？可以详细说一下吗？</p><p><strong>候选人：</strong>嗯，这个比较清楚，ACID，分别指的是：原子性、一致性、隔离性、持久性；我举个例子：</p><p>A向B转账500，转账成功，A扣除500元，B增加500元，原子操作体现在要么都成功，要么都失败</p><p>在转账的过程中，数据要一致，A扣除了500，B必须增加500</p><p>在转账的过程中，隔离性体现在A像B转账，不能受其他事务干扰</p><p>在转账的过程中，持久性体现在事务提交后，要把数据持久化（可以说是落盘操作）</p><p><strong>面试官</strong>：并发事务带来哪些问题？</p><p><strong>候选人</strong>：</p><p>我们在项目开发中，多个事务并发进行是经常发生的，并发也是必然的，有可能导致一些问题</p><p>第一是脏读， 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p><p>第二是不可重复读：比如在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><p>第三是幻读（Phantom read）：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><p><strong>面试官</strong>：怎么解决这些问题呢？MySQL的默认隔离级别是？</p><p><strong>候选人</strong>：解决方案是对事务进行隔离</p><p>MySQL支持四种隔离级别，分别有：</p><p>第一个是，未提交读（read uncommitted）它解决不了刚才提出的所有问题，一般项目中也不用这个。第二个是读已提交（read committed）它能解决脏读的问题的，但是解决不了不可重复读和幻读。第三个是可重复读（repeatable read）它能解决脏读和不可重复读，但是解决不了幻读，这个也是mysql默认的隔离级别。第四个是串行化（serializable）它可以解决刚才提出来的所有问题，但是由于让是事务串行执行的，性能比较低。所以，我们一般使用的都是mysql默认的隔离级别:可重复读</p><p><strong>面试官</strong>：undo log和redo log的区别</p><p><strong>候选人</strong>：好的，其中redo log日志记录的是数据页的物理变化，服务宕机可用来同步数据，而undo log 不同，它主要记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据，比如我们删除一条数据的时候，就会在undo log日志文件中新增一条delete语句，如果发生回滚就执行逆操作；</p><p>redo log保证了事务的持久性，undo log保证了事务的原子性和一致性</p><p><strong>面试官</strong>：事务中的隔离性是如何保证的呢？(你解释一下MVCC)</p><p><strong>候选人</strong>：事务的隔离性是由锁和mvcc实现的。</p><p>其中mvcc的意思是多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，它的底层实现主要是分为了三个部分，第一个是隐藏字段，第二个是undo log日志，第三个是readView读视图</p><p>隐藏字段是指：在mysql中给每个表都设置了隐藏字段，有一个是trx_id(事务id)，记录每一次操作的事务id，是自增的；另一个字段是roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址</p><p>undo log主要的作用是记录回滚日志，存储老版本数据，在内部会形成一个版本链，在多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表</p><p>readView解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务id判断该访问那个版本的数据，不同的隔离级别快照读是不一样的，最终的访问的结果不一样。如果是rc隔离级别，每一次执行快照读时生成ReadView，如果是rr隔离级别仅在事务中第一次执行快照读时生成ReadView，后续复用</p><p><strong>面试官</strong>：MySQL主从同步原理 </p><p><strong>候选人</strong>：MySQL主从复制的核心就是二进制日志(DDL（数据定义语言）语句和 DML（数据操纵语言）语句)，它的步骤是这样的：</p><p>第一：主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</p><p>第二：从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</p><p>第三：从库重做中继日志中的事件，将改变反映它自己的数据</p><p><strong>面试官</strong>：你们项目用过MySQL的分库分表吗？</p><p><strong>候选人</strong>：</p><p>嗯，因为我们都是微服务开发，每个微服务对应了一个数据库，是根据业务进行拆分的，这个其实就是垂直拆分。</p><p><strong>面试官</strong>：那你之前使用过水平分库吗？</p><p><strong>候选人</strong>：</p><p>嗯，这个是使用过的，我们当时的业务是(xxx)，一开始，我们也是单库，后来这个业务逐渐发展，业务量上来的很迅速，其中(xx)表已经存放了超过1000万的数据，我们做了很多优化也不好使，性能依然很慢，所以当时就使用了水平分库。</p><p>我们一开始先做了3台服务器对应了3个数据库，由于库多了，需要分片，我们当时采用的mycat来作为数据库的中间件。数据都是按照id（自增）取模的方式来存取的。</p><p>当然一开始的时候，那些旧数据，我们做了一些清洗的工作，我们也是按照id取模规则分别存储到了各个数据库中，好处就是可以让各个数据库分摊存储和读取的压力，解决了我们当时性能的问题</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>框架面试题</title>
      <link href="/2023/10/18/%E6%A1%86%E6%9E%B6%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/10/18/%E6%A1%86%E6%9E%B6%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="框架篇面试题-参考回答"><a href="#框架篇面试题-参考回答" class="headerlink" title="框架篇面试题-参考回答"></a>框架篇面试题-参考回答</h2><blockquote><h5 id="面试官：Spring框架中的单例bean是线程安全的吗？"><a href="#面试官：Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="面试官：Spring框架中的单例bean是线程安全的吗？"></a><strong>面试官</strong>：Spring框架中的单例bean是线程安全的吗？</h5><p><strong>候选人</strong>：</p><p>嗯！</p><p>不是线程安全的，是这样的</p><p>当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求对应的业务逻辑（成员方法），如果该处理逻辑中有对该单列状态的修改（体现为该单例的成员属性），则必须考虑线程同步问题。</p><p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。</p><p>比如：我们通常在项目中使用的Spring bean都是不可可变的状态(比如Service类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。</p><p>如果你的bean有多种状态的话（比如 View Model对象），就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用由“<strong>singleton</strong>”变更为“<strong>prototype</strong>”。</p><p><strong>面试官</strong>：什么是AOP</p><p><strong>候选人</strong>：</p><p>aop是面向切面编程，在spring中用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合，一般比如可以做为公共日志保存，事务处理等</p><p><strong>面试官</strong>：你们项目中有没有使用到AOP</p><p><strong>候选人</strong>：</p><p>我们当时在后台管理系统中，就是使用aop来记录了系统的操作日志</p><p>主要思路是这样的，使用aop中的环绕通知+切点表达式，这个表达式就是要找到要记录日志的方法，然后通过环绕通知的参数获取请求方法的参数，比如类信息、方法信息、注解、请求方式等，获取到这些参数以后，保存到数据库</p><p><strong>面试官</strong>：Spring中的事务是如何实现的</p><p><strong>候选人</strong>：</p><p>spring实现的事务本质就是aop完成，对方法前后进行拦截，在执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p><p><strong>面试官</strong>：Spring中事务失效的场景有哪些</p><p><strong>候选人</strong>：</p><p>嗯！这个在项目中之前遇到过，我想想啊</p><p>第一个，如果方法上异常捕获处理，自己处理了异常，没有抛出，就会导致事务失效，所以一般处理了异常以后，别忘了跑出去就行了</p><p>第二个，如果方法抛出检查异常，如果报错也会导致事务失效，最后在spring事务的注解上，就是@Transactional上配置rollbackFor属性为Exception，这样别管是什么异常，都会回滚事务</p><p>第三，我之前还遇到过一个，如果方法上不是public修饰的，也会导致事务失效</p><p>嗯，就能想起来那么多</p><p><strong>面试官</strong>：Spring的bean的生命周期</p><p><strong>候选人</strong>：</p><p>嗯！，这个步骤还是挺多的，我之前看过一些源码，它大概流程是这样的</p><p>首先会通过一个非常重要的类，叫做BeanDefinition获取bean的定义信息，这里面就封装了bean的所有信息，比如，类的全路径，是否是延迟加载，是否是单例等等这些信息</p><p>在创建bean的时候，第一步是调用构造函数实例化bean</p><p>第二步是bean的依赖注入，比如一些set方法注入，像平时开发用的@Autowire都是这一步完成</p><p>第三步是处理Aware接口，如果某一个bean实现了Aware接口就会重写方法执行</p><p>第四步是bean的后置处理器BeanPostProcessor，这个是前置处理器</p><p>第五步是初始化方法，比如实现了接口InitializingBean或者自定义了方法init-method标签或@PostContruct</p><p>第六步是执行了bean的后置处理器BeanPostProcessor，主要是对bean进行增强，有可能在这里产生代理对象</p><p>最后一步是销毁bean</p><p><strong>面试官</strong>：Spring中的循环引用</p><p><strong>候选人</strong>：</p><p>嗯，好的，我来解释一下</p><p>循环依赖：循环依赖其实就是循环引用,也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A</p><p>循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖</p><p>①一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</p><p>②二级缓存：缓存早期的bean对象（生命周期还没走完）</p><p>③三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</p><p><strong>面试官</strong>：那具体解决流程清楚吗？</p><p><strong>候选人</strong>：</p><p>第一，先实例A对象，同时会创建ObjectFactory对象存入三级缓存singletonFactories  </p><p>第二，A在初始化的时候需要B对象，这个走B的创建的逻辑</p><p>第三，B实例化完成，也会创建ObjectFactory对象存入三级缓存singletonFactories  </p><p>第四，B需要注入A，通过三级缓存中获取ObjectFactory来生成一个A的对象同时存入二级缓存，这个是有两种情况，一个是可能是A的普通对象，另外一个是A的代理对象，都可以让ObjectFactory来生产对应的对象，这也是三级缓存的关键</p><p>第五，B通过从通过二级缓存earlySingletonObjects  获得到A的对象后可以正常注入，B创建成功，存入一级缓存singletonObjects  </p><p>第六，回到A对象初始化，因为B对象已经创建完成，则可以直接注入B，A创建成功存入一次缓存singletonObjects </p><p>第七，二级缓存中的临时对象A清除 </p><p><strong>面试官</strong>：构造方法出现了循环依赖怎么解决？</p><p><strong>候选人</strong>：</p><p>由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入，可以使用@Lazy懒加载，什么时候需要对象再进行bean对象的创建</p><p><strong>面试官</strong>：SpringMVC的执行流程知道嘛</p><p><strong>候选人</strong>：</p><p>嗯，这个知道的，它分了好多步骤</p><p>1、用户发送出请求到前端控制器DispatcherServlet，这是一个调度中心</p><p>2、DispatcherServlet收到请求调用HandlerMapping（处理器映射器）。</p><p>3、HandlerMapping找到具体的处理器(可查找xml配置或注解配置)，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。</p><p>4、DispatcherServlet调用HandlerAdapter（处理器适配器）。</p><p>5、HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）。</p><p>6、Controller执行完成返回ModelAndView对象。</p><p>7、HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet。</p><p>8、DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）。</p><p>9、ViewReslover解析后返回具体View（视图）。</p><p>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p><p>11、DispatcherServlet响应用户。</p><p>当然现在的开发，基本都是前后端分离的开发的，并没有视图这些，一般都是handler中使用Response直接结果返回</p><p><strong>面试官</strong>：Springboot自动配置原理</p><p><strong>候选人</strong>：</p><p>嗯，好的，它是这样的。</p><p>在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个注解是对三个注解进行了封装，分别是：</p><ul><li><p>@SpringBootConfiguration</p></li><li><p>@EnableAutoConfiguration</p></li><li><p>@ComponentScan</p></li></ul><p>其中<code>@EnableAutoConfiguration</code>是实现自动化配置的核心注解。 </p><p>该注解通过<code>@Import</code>注解导入对应的配置选择器。关键的是内部就是读取了该项目和该项目引用的Jar包的的classpath路径下<strong>META-INF&#x2F;spring.factories</strong>文件中的所配置的类的全类名。 </p><p>在这些配置类中所定义的Bean会根据条件注解所<strong>指定的条件来决定</strong>是否需要将其导入到Spring容器中。</p><p>一般条件判断会有像<code>@ConditionalOnClass</code>这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。</p><p><strong>面试官</strong>：Spring 的常见注解有哪些？</p><p><strong>候选人</strong>：</p><p>嗯，这个就很多了</p><p>第一类是：声明bean，有@Component、@Service、@Repository、@Controller</p><p>第二类是：依赖注入相关的，有@Autowired、@Qualifier、@Resourse</p><p>第三类是：设置作用域 @Scope</p><p>第四类是：spring配置相关的，比如@Configuration，@ComponentScan 和 @Bean </p><p>第五类是：跟aop相关做增强的注解  @Aspect，@Before，@After，@Around，@Pointcut</p><p><strong>面试官</strong>：SpringMVC常见的注解有哪些？</p><p><strong>候选人</strong>：</p><p>嗯，这个也很多的</p><p>有@RequestMapping：用于映射请求路径；</p><p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象；</p><p>@RequestParam：指定请求参数的名称；</p><p>@PathViriable：从请求路径下中获取请求参数(&#x2F;user&#x2F;{id})，传递给方法的形式参数；@ResponseBody：注解实现将controller方法返回对象转化为json对象响应给客户端。@RequestHeader：获取指定的请求头数据，还有像@PostMapping、@GetMapping这些。</p><p><strong>面试官</strong>：Springboot常见注解有哪些？</p><p><strong>候选人</strong>：</p><p>嗯~~</p><p>Spring Boot的核心注解是@SpringBootApplication , 他由几个注解组成 : </p><ul><li>@SpringBootConfiguration： 组合了- @Configuration注解，实现配置文件的功能；</li><li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项</li><li>@ComponentScan：Spring组件扫描</li></ul><p><strong>面试官</strong>：MyBatis执行流程</p><p><strong>候选人</strong>：</p><p>好，这个知道的，不过步骤也很多</p><p>①读取MyBatis配置文件：mybatis-config.xml加载运行环境和映射文件</p><p>②构造会话工厂SqlSessionFactory，一个项目只需要一个，单例的，一般由spring进行管理</p><p>③会话工厂创建SqlSession对象，这里面就含了执行SQL语句的所有方法</p><p>④操作数据库的接口，Executor执行器，同时负责查询缓存的维护</p><p>⑤Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</p><p>⑥输入参数映射</p><p>⑦输出结果映射</p><p><strong>面试官</strong>：Mybatis是否支持延迟加载？</p><p><strong>候选人</strong>：</p><p>是支持的~</p><p>延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。</p><p>Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载</p><p>在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false，默认是关闭的</p><p><strong>面试官</strong>：延迟加载的底层原理知道吗？</p><p><strong>候选人</strong>：</p><p>嗯，我想想啊</p><p>延迟加载在底层主要使用的CGLIB动态代理完成的</p><p>第一是，使用CGLIB创建目标对象的代理对象，这里的目标对象就是开启了延迟加载的mapper</p><p>第二个是当调用目标方法时，进入拦截器invoke方法，发现目标方法是null值，再执行sql查询</p><p>第三个是获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了</p><p><strong>面试官</strong>：Mybatis的一级、二级缓存用过吗？</p><p><strong>候选人</strong>：</p><p>嗯~~，用过的~</p><p>mybatis的一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存</p><p>关于二级缓存需要单独开启</p><p>二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQL session，默认也是采用 PerpetualCache，HashMap 存储。</p><p>如果想要开启二级缓存需要在全局配置文件和映射文件中开启配置才行。</p><p><strong>面试官</strong>：Mybatis的二级缓存什么时候会清理缓存中的数据</p><p><strong>候选人</strong>：</p><p>嗯！！</p><p>当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring,SpringMVC,SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务面试题</title>
      <link href="/2023/10/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/10/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="微服务面试题"><a href="#微服务面试题" class="headerlink" title="微服务面试题"></a>微服务面试题</h2><blockquote><p><strong>面试官：</strong>Spring Cloud 5大组件有哪些？</p><p><strong>候选人：</strong></p><p>早期我们一般认为的Spring Cloud五大组件是 </p><ul><li>Eureka   : 注册中心</li><li>Ribbon  : 负载均衡</li><li>Feign     : 远程调用</li><li>Hystrix :  服务熔断</li><li>Zuul&#x2F;Gateway  : 网关</li></ul><p>随着SpringCloudAlibba在国内兴起 , 我们项目中使用了一些阿里巴巴的组件 </p><ul><li><p>注册中心&#x2F;配置中心 Nacos</p></li><li><p>负载均衡 Ribbon</p></li><li><p>服务调用 Feign</p></li><li><p>服务保护 sentinel</p></li><li><p>服务网关 Gateway</p></li></ul><p><strong>面试官：</strong>服务注册和发现是什么意思？Spring Cloud 如何实现服务注册发现？</p><p><strong>候选人：</strong></p><p>我理解的是主要三块大功能，分别是服务注册 、服务发现、服务状态监控</p><p>我们当时项目采用的eureka作为注册中心，这个也是spring cloud体系中的一个核心组件</p><p><strong>服务注册</strong>：服务提供者需要把自己的信息注册到eureka，由eureka来保存这些信息，比如服务名称、ip、端口等等</p><p><strong>服务发现</strong>：消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用</p><p><strong>服务监控</strong>：服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果eureka服务90秒没接收到心跳，从eureka中剔除</p><p><strong>面试官：</strong>我看你之前也用过nacos、你能说下nacos与eureka的区别？</p><p><strong>候选人：</strong></p><p>我们当时xx项目就是采用的nacos作为注册中心，选择nacos还要一个重要原因就是它支持配置中心，不过nacos作为注册中心，也比eureka要方便好用一些，主要相同不同点在于几点：</p><ul><li>共同点</li></ul><p>Nacos与eureka都支持服务注册和服务拉取，都支持服务提供者心跳方式做健康检测</p><ul><li>Nacos与Eureka的区别</li></ul><p>①Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</p><p>②临时实例心跳不正常会被剔除，非临时实例则不会被剔除</p><p>③Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</p><p>④Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</p><p><strong>面试官：</strong>你们项目负载均衡如何实现的 ? </p><p><strong>候选人：</strong></p><p>是这样~~</p><p>在服务调用过程中的负载均衡一般使用SpringCloud的Ribbon 组件实现  , Feign的底层已经自动集成了Ribbon  , 使用起来非常简单</p><p>当发起远程调用时，ribbon先从注册中心拉取服务地址列表，然后按照一定的路由策略选择一个发起远程调用，一般的调用策略是轮询</p><p><strong>面试官：</strong>Ribbon负载均衡策略有哪些 ? </p><p><strong>候选人：</strong></p><p>我想想啊，有很多种，我记得几个：</p><ul><li><p>RoundRobinRule：简单轮询服务列表来选择服务器</p></li><li><p>WeightedResponseTimeRule：按照权重来选择服务器，响应时间越长，权重越小</p></li><li><p>RandomRule：随机选择一个可用的服务器</p></li><li><p>ZoneAvoidanceRule：区域敏感策略，以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询(默认)</p></li></ul><p><strong>面试官：</strong>如果想自定义负载均衡策略如何实现 ? </p><p><strong>候选人：</strong></p><p>提供了两种方式：</p><p>1，创建类实现IRule接口，可以指定负载均衡策略，这个是全局的，对所有的远程调用都起作用</p><p>2，在客户端的配置文件中，可以配置某一个服务调用的负载均衡策略，只是对配置的这个服务生效远程调用</p><p><strong>面试官：</strong>什么是服务雪崩，怎么解决这个问题？</p><p><strong>候选人：</strong></p><p>服务雪崩是指一个服务失败，导致整条链路的服务都失败的情形，一般我们在项目解决的话就是两种方案，第一个是服务降级，第二个是服务熔断，如果流量太大的话，可以考虑限流</p><p>服务降级：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，一般在实际开发中与feign接口整合，编写降级逻辑</p><p>服务熔断：默认关闭，需要手动打开，如果检测到 10 秒内请求的失败率超过 50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</p><p><strong>面试官：</strong>你们的微服务是怎么监控的？</p><p><strong>候选人：</strong></p><p>我们项目中采用的skywalking进行监控的</p><p>1，skywalking主要可以监控接口、服务、物理实例的一些状态。特别是在压测的时候可以看到众多服务中哪些服务和接口比较慢，我们可以针对性的分析和优化。</p><p>2，我们还在skywalking设置了告警规则，特别是在项目上线以后，如果报错，我们分别设置了可以给相关负责人发短信和发邮件，第一时间知道项目的bug情况，第一时间修复</p><p><strong>面试官：</strong>你们项目中有没有做过限流 ? 怎么做的 ?</p><p><strong>候选人：</strong></p><p>我当时做的xx项目，采用就是微服务的架构，因为xx因为，应该会有突发流量，最大QPS可以达到2000，但是服务支撑不住，我们项目都通过压测最多可以支撑1200QPS。因为我们平时的QPS也就不到100，为了解决这些突发流量，所以采用了限流。</p><p>【版本1】</p><p>我们当时采用的nginx限流操作，nginx使用的漏桶算法来实现过滤，让请求以固定的速率处理请求，可以应对突发流量，我们控制的速率是按照ip进行限流，限制的流量是每秒20</p><p>【版本2】</p><p>我们当时采用的是spring cloud gateway中支持局部过滤器RequestRateLimiter来做限流，使用的是令牌桶算法，可以根据ip或路径进行限流，可以设置每秒填充平均速率，和令牌桶总容量</p><p><strong>面试官：</strong>限流常见的算法有哪些呢？</p><p><strong>候选人：</strong></p><p>比较常见的限流算法有漏桶算法和令牌桶算法</p><p>漏桶算法是把请求存入到桶中，以固定速率从桶中流出，可以让我们的服务做到绝对的平均，起到很好的限流效果</p><p>令牌桶算法在桶中存储的是令牌，按照一定的速率生成令牌，每个请求都要先申请令牌，申请到令牌以后才能正常请求，也可以起到很好的限流作用</p><p>它们的区别是，漏桶和令牌桶都可以处理突发流量，其中漏桶可以做到绝对的平滑，令牌桶有可能会产生突发大量请求的情况，一般nginx限流采用的漏桶，spring cloud gateway中可以支持令牌桶算法</p><p><strong>面试官</strong>：什么是CAP理论？</p><p><strong>候选人</strong>：</p><p>CAP主要是在分布式项目下的一个理论。包含了三项，一致性、可用性、分区容错性</p><ul><li><p>一致性(Consistency)是指更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致(强一致性)，不能存在中间状态。</p></li><li><p>可用性(Availability) 是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p></li><li><p>分区容错性(Partition tolerance) 是指分布式系统在遇到任何网络分区故障时，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p></li></ul><p><strong>面试官</strong>：为什么分布式系统中无法同时保证一致性和可用性？</p><p><strong>候选人</strong>：</p><p>嗯，是这样的~~</p><p>首先一个前提，对于分布式系统而言，分区容错性是一个最基本的要求，因此基本上我们在设计分布式系统的时候只能从一致性（C）和可用性（A）之间进行取舍。</p><p>如果保证了一致性（C）：对于节点N1和N2，当往N1里写数据时，N2上的操作必须被暂停，只有当N1同步数据到N2时才能对N2进行读写请求，在N2被暂停操作期间客户端提交的请求会收到失败或超时。显然，这与可用性是相悖的。</p><p>如果保证了可用性（A）：那就不能暂停N2的读写操作，但同时N1在写数据的话，这就违背了一致性的要求。</p><p><strong>面试官</strong>：什么是BASE理论？</p><p><strong>候选人</strong>：</p><p>嗯，这个也是CAP分布式系统设计理论</p><p>BASE是CAP理论中AP方案的延伸，核心思想是即使无法做到强一致性（StrongConsistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。它的思想包含三方面：</p><p>1、Basically Available（基本可用）：基本可用是指分布式系统在出现不可预知的故障的时候，允许损失部分可用性，但不等于系统不可用。</p><p>2、Soft state（软状态）：即是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><p>3、Eventually consistent（最终一致性）：强调系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。其本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><p><strong>面试官：</strong>你们采用哪种分布式事务解决方案？</p><p><strong>候选人：</strong></p><p>我们当时是xx项目，主要使用到的seata的at模式解决的分布式事务</p><p>seata的AT模型分为两个阶段：</p><p>1、阶段一RM的工作：① 注册分支事务  ② 记录undo-log（数据快照）③ 执行业务sql并提交 ④报告事务状态</p><p>2、阶段二提交时RM的工作：删除undo-log即可</p><p>3、阶段二回滚时RM的工作：根据undo-log恢复数据到更新前</p><p>at模式牺牲了一致性，保证了可用性，不过，它保证的是最终一致性</p><p><strong>面试官：</strong>分布式服务的接口幂等性如何设计？</p><p><strong>候选人：</strong></p><p>嗯，我们当时有一个xx项目的下单操作，采用的token+redis实现的，流程是这样的</p><p>第一次请求，也就是用户打开了商品详情页面，我们会发起一个请求，在后台生成一个唯一token存入redis，key就是用户的id，value就是这个token，同时把这个token返回前端</p><p>第二次请求，当用户点击了下单操作会后，会携带之前的token，后台先到redis进行验证，如果存在token，可以执行业务，同时删除token；如果不存在，则直接返回，不处理业务，就保证了同一个token只处理一次业务，就保证了幂等性</p><p><strong>面试官：</strong>xxl-job路由策略有哪些？</p><p><strong>候选人：</strong></p><p>xxl-job提供了很多的路由策略，我们平时用的较多就是：轮询、故障转移、分片广播…</p><p><strong>面试官：</strong>xxl-job任务执行失败怎么解决？</p><p><strong>候选人：</strong></p><p>有这么几个操作</p><p>第一：路由策略选择故障转移，优先使用健康的实例来执行任务</p><p>第二，如果还有失败的，我们在创建任务时，可以设置重试次数</p><p>第三，如果还有失败的，就可以查看日志或者配置邮件告警来通知相关负责人解决</p><p><strong>面试官：</strong>如果有大数据量的任务同时都需要执行，怎么解决？</p><p><strong>候选人：</strong></p><p>我们会让部署多个实例，共同去执行这些批量的任务，其中任务的路由策略是分片广播</p><p>在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行就可以了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud,微服务 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
