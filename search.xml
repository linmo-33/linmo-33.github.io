<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis篇-缓存</title>
      <link href="/2023/10/18/Redis%E7%AF%87-%E7%BC%93%E5%AD%98/"/>
      <url>/2023/10/18/Redis%E7%AF%87-%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis使用场景-缓存-缓存穿透"><a href="#Redis使用场景-缓存-缓存穿透" class="headerlink" title="Redis使用场景-缓存-缓存穿透"></a>Redis使用场景-缓存-缓存穿透</h2><p><strong>缓存穿透</strong>：查询一个不存在的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库</p><p><strong>解决方案一</strong>：缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存</p><p>优点：简单</p><p>缺点：消耗内存，可能会发生不一致的问题</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310181124681.png" alt="image-20231018112405592"></p><p><strong>解决方案二</strong>：布隆过滤器</p><p>优点：内存占用较少，没有多余key</p><p>缺点：实现复杂，存在误判</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310181358187.png" alt="image-20231018112311654"></p><h2 id="Redis使用场景-缓存-缓存击穿"><a href="#Redis使用场景-缓存-缓存击穿" class="headerlink" title="Redis使用场景-缓存-缓存击穿"></a>Redis使用场景-缓存-缓存击穿</h2><p><strong>缓存击穿</strong>：给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个key有大量的并发请求过来，这些并发的请求可能会瞬间把DB压垮</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310181125239.png" alt="image-20231018112553177"></p><p><strong>解决方案一</strong>：互斥锁</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310181128465.png" alt="image-20231018112838406"></p><p>强一致，性能差</p><p><strong>解决方案二</strong>：逻辑过期</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310181132902.png" alt="image-20231018113207779"></p><p>高可用，性能优，不能保证数据的强一致</p><h2 id="Redis使用场景-缓存-缓存雪崩"><a href="#Redis使用场景-缓存-缓存雪崩" class="headerlink" title="Redis使用场景-缓存-缓存雪崩"></a>Redis使用场景-缓存-缓存雪崩</h2><p><strong>缓存雪崩</strong>：是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p><strong>解决方案</strong>：</p><ul><li>给不同的Key的TTL(过期时间)添加随机值</li><li>利用Redis集群提高服务的可用     性哨兵模式、集群模式</li><li>给缓存业务添加降级限流策略       ngxin或spring cloud gateway</li><li>给业务添加多级缓存       Guava或Caffeine</li></ul><h2 id="Redis使用场景-缓存-双写一致性"><a href="#Redis使用场景-缓存-双写一致性" class="headerlink" title="Redis使用场景-缓存-双写一致性"></a>Redis使用场景-缓存-双写一致性</h2><p><strong>双写一致性</strong>：当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p><p><strong>允许延时一致的业务，采用异步通知</strong></p><p>​    ①使用MQ中间中间件，更新数据之后，通知缓存删除</p><p>​    ②利用canal中间件，不需要修改业务代码，伪装为mysql的一个从节点，canali通过读取binlog数据更新缓存</p><p><strong>强一致性的，采用Redisson提供的读写锁</strong></p><p>​    ①共享锁：读锁readLock,加锁之后，其他线程可以共享读操作</p><p>​    ②排他锁：独占锁writeLock也叫，加锁后，阻塞其他线程读写操作</p><h2 id="Redis使用场景-缓存-持久化"><a href="#Redis使用场景-缓存-持久化" class="headerlink" title="Redis使用场景-缓存-持久化"></a>Redis使用场景-缓存-持久化</h2><blockquote><p><strong>RDB</strong></p></blockquote><p><strong>RDB</strong>全称Redis Database Backup file(Redis数据备份文件)，也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Rdis实例故障重启后，从磁盘读取快照文件，恢复数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ]redis-cli </span><br><span class="line">127.0.0.1:6379&gt;save<span class="comment">#由Redis主进程来执行RDB,会阻塞所有命令 </span></span><br><span class="line">ok </span><br><span class="line">127.0.0.1:6379&gt;bgsave<span class="comment">#开启子进程执行RDB,避免主进程受到影响 </span></span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#90o秒内，如果至少有1个key被修改，则执行bgsave </span></span><br><span class="line">save 900 1 </span><br><span class="line">save 300 10 </span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p><strong>RDB</strong>执行原理：bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入RDB文件。</p><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><blockquote><p><strong>AOF</strong></p></blockquote><p><strong>AOF</strong>全称为Append Only File(追加文件)。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no </span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line"><span class="comment">#AOF文件的名称 </span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#表示每执行一次写命令，立即记录到AOF文件 </span></span><br><span class="line">appendfsync always</span><br><span class="line"><span class="comment">#写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案 </span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment">#写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘 </span></span><br><span class="line">appendfsync no</span><br></pre></td></tr></table></figure><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个ky的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#AOF文件比上次文件增长超过多少百分比则触发重写 </span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="comment">#A0F文件体积最小多大以上才触发重写 </span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用。</p><table><thead><tr><th align="center"></th><th align="center">RDB</th><th align="center">AOF</th></tr></thead><tbody><tr><td align="center">持久化方式</td><td align="center">定时对整个内存做快照</td><td align="center">记录每一次的执行命令</td></tr><tr><td align="center">数据完整性</td><td align="center">不完整，两次备份之间会丢失</td><td align="center">相对完整，却决于刷盘策略</td></tr><tr><td align="center">文件大小</td><td align="center">会有压缩，文件体积小</td><td align="center">记录命令，文件体积大</td></tr><tr><td align="center">宕机恢复速度</td><td align="center">很快</td><td align="center">慢</td></tr><tr><td align="center">数据恢复优先级</td><td align="center">低，因为数据完整性不如AOF</td><td align="center">高，因为数据完整性高</td></tr><tr><td align="center">系统资源占用</td><td align="center">高，大量CPU和内存消耗</td><td align="center">低，主要是磁盘IO资源，但AOF重写时会占用大量的CPU和内存资源</td></tr><tr><td align="center">使用场景</td><td align="center">可以容忍数分钟的数据丢失，追求更快的启动速度</td><td align="center">对数据安全性要求较高常见</td></tr></tbody></table><h2 id="Redis使用场景-缓存-数据过期策略"><a href="#Redis使用场景-缓存-数据过期策略" class="headerlink" title="Redis使用场景-缓存-数据过期策略"></a>Redis使用场景-缓存-数据过期策略</h2><blockquote><p><strong>Redisi数据删除策略-惰性删除</strong></p></blockquote><p><strong>惰性删除</strong>：设置该key过期时间后，我们不去管它，当需要该ky时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key</p><p>优点：对CPU友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查</p><p>缺点：对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存中，内存永远不会释放</p><blockquote><p><strong>Redisi数据删除策略-定期删除</strong></p></blockquote><p><strong>定期删除</strong>：每隔一段时间，我们就对一些ky进行检查，删除里面过期的key(从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key)。</p><p>定期清理有两种模式：</p><ul><li>SLOW模式是定时任务，执行频率默认为10hz,每次不超过25ms,以通过修改配置文件redis..conf的hz选项来调整这个次数</li><li>FAST模式执行频率不固定，但两次间隔不低于2ms,每次耗时不超过1ms</li></ul><p>优点：可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。另外定期删除，也能有效释放过期键占用的内存。</p><p>缺点：难以确定删除操作执行的时长和频率。</p><p><strong>Redis的过期删除策略：惰性删除+定期删除两种策略进行配合使用</strong></p><h2 id="Redis使用场景-缓存-数据淘汰策略"><a href="#Redis使用场景-缓存-数据淘汰策略" class="headerlink" title="Redis使用场景-缓存-数据淘汰策略"></a>Redis使用场景-缓存-数据淘汰策略</h2><p><strong>数据的淘汰策略</strong>：当Redis中的内存不够用时，此时在向Redis中添加新的key,那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。</p><p>1.Redis提供了8种不同的数据淘汰策略，默认是noeviction不删除任何数据，内存不足直接报错</p><p>2.LRU:最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</p><p>3.LFU:最少频率使用。会统计每个ky的访问频率，值越小淘汰优先级越高</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM笔记（一）</title>
      <link href="/2023/10/14/JVM%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
      <url>/2023/10/14/JVM%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="一、JVM的基础概念"><a href="#一、JVM的基础概念" class="headerlink" title="一、JVM的基础概念"></a>一、JVM的基础概念</h2><p>JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···</p><p>JVM 其实就类似于一台小电脑运行在 windows 或者 linux 这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310162156977.png" alt="image-20231016215639615"></p><p>###1.java程序是如何运行的</p><p><img src="https://cdn.jsdelivr.net/gh/linmo-33/imgs/img/202310162229652.png" alt="image-20231016222900570"></p><p>比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。</p><p>那我们的 <strong>JVM</strong> 是不认识文本文件的，所以它需要一个 <strong>编译</strong> ，让其成为一个它会读二进制文件的 <strong>HelloWorld.class</strong></p><h4 id="（1）类加载器"><a href="#（1）类加载器" class="headerlink" title="（1）类加载器"></a>（1）类加载器</h4><h4 id="（2）方法区"><a href="#（2）方法区" class="headerlink" title="（2）方法区"></a>（2）方法区</h4><h4 id="（3）堆"><a href="#（3）堆" class="headerlink" title="（3）堆"></a>（3）堆</h4><h4 id="（4）栈"><a href="#（4）栈" class="headerlink" title="（4）栈"></a>（4）栈</h4><h4 id="（5）程序计数器"><a href="#（5）程序计数器" class="headerlink" title="（5）程序计数器"></a>（5）程序计数器</h4>]]></content>
      
      
      <categories>
          
          <category> //文章匪类目录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
